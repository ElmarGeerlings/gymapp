    1: console.log('gainz.js script started execution.'); // Log at the very top
    2: 
    3: // ======================================
    4: //          CORE FRAMEWORK
    5: // ======================================
    6: 
    7: // WebSocket Setup (from stolen_js.js example)
    8: // const port = window.location.port ? `:${window.location.port}` : '';
    9: // const wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
   10: // const wsUrl = `${wsProtocol}://${window.location.hostname}${port}/ws/gainz/`; // Adjusted path
   11: 
   12: // let ws = null;
   13: // const requestMap = new Map();
   14: // let reconnectAttempts = 0;
   15: // const maxReconnectAttempts = 10;
   16: // const reconnectInterval = 3000; // 3 seconds
   17: 
   18: // function connectWebSocket() { // REMOVED
   19:     // ... WebSocket connection logic ...
   20: // }
   21: 
   22: // Initialize WebSocket connection
   23: // connectWebSocket(); // REMOVED
   24: 
   25: 
   26: // Loading Indicator (can be kept if used by httpRequestHelper or other AJAX calls, or removed if only for WebSockets)
   27: // let intervalId; // REMOVED if show/hideLoading are removed
   28: // function showLoading() { // REMOVED or adapted for general AJAX
   29:     // ... loading logic ...
   30: // }
   31: 
   32: // function hideLoading() { // REMOVED or adapted for general AJAX
   33:     // ... loading logic ...
   34: // }
   35: 
   36: // sendWsRequest (from stolen_js.js example, adapted)
   37: // function sendWsRequest(endpoint, element) { // REMOVED
   38:     // ... WebSocket send logic ...
   39: // }
   40: 
   41: let mutationObserverStarted = false;
   42: 
   43: function process_mutations(mutations) {
   44:     mutations.forEach(mutation => {
   45:         if (mutation.type === "attributes") {
   46:             const attrName = mutation.attributeName;
   47:             // Only watch data-function if data-endpoint is truly removed
   48:             if (attrName === 'data-function') {
   49:                 handle_attribute(mutation.target, mutation.target.getAttributeNode(attrName));
   50:             }
   51:         } else if (mutation.type === "childList") {
   52:             mutation.addedNodes.forEach(node => {
   53:                 if (node.nodeType === Node.ELEMENT_NODE) {
   54:                     // Check the added node itself
   55:                     if (node.matches('[data-function]')) {
   56:                          handle_attribute(node, node.getAttributeNode('data-function'));
   57:                     }
   58:                     // Check descendants
   59:                     node.querySelectorAll('[data-function]').forEach(element => {
   60:                         handle_attribute(element, element.getAttributeNode('data-function'));
   61:                     });
   62:                 }
   63:             });
   64:         }
   65:     });
   66: }
   67: 
   68: const observer = new MutationObserver(process_mutations);
   69: 
   70: function handle_attribute(element, attr) {
   71:     if (!attr || !attr.value) return;
   72:     const attr_values = attr.value.trim().split(' ');
   73:     const attrName = attr.name;
   74: 
   75:     attr_values.forEach(value => {
   76:         const parts = value.split('->');
   77:         if (parts.length !== 2) {
   78:             console.warn(`Invalid ${attrName} format: ${value}. Expected eventName->targetName.`);
   79:             return;
   80:         }
   81:         const [eventName, targetName] = parts;
   82: 
   83:         // Debugging log for the specific button
   84:         if (element.id === 'add-exercise-btn' && eventName === 'click' && targetName === 'showAddExerciseToRoutineModal') {
   85:             console.log('Attempting to bind click->showAddExerciseToRoutineModal to #add-exercise-btn');
   86:         }
   87: 
   88:         const listenerKey = `_${attrName}_${eventName}_${targetName}_listener`;
   89:         if (element[listenerKey]) {
   90:              element.removeEventListener(eventName, element[listenerKey]);
   91:         }
   92: 
   93:         let listener;
   94:         if (attrName === 'data-function') {
   95:             if (typeof window[targetName] === 'function') {
   96:                 listener = (event) => window[targetName](event);
   97:             } else {
   98:                 console.warn(`Global function ${targetName} not found.`);
   99:                 return;
  100:             }
  101:         }
  102:         // Removed data-endpoint handling based on user comment
  103:         /* else if (attrName === 'data-endpoint') {
  104:             listener = (event) => http_request(event, targetName);
  105:         } */
  106: 
  107:         if (listener) {
  108:             element.addEventListener(eventName, listener);
  109:             element[listenerKey] = listener;
  110:         }
  111:     });
  112: }
  113: 
  114: // Store the original program state for cancel functionality
  115: let originalProgramState = null;
  116: 
  117: function saveProgramState() {
  118:     const state = {
  119:         schedulingType: document.getElementById('scheduling-weekly').checked ? 'weekly' : 'sequential',
  120:         weeklyRoutines: {},
  121:         sequentialRoutines: []
  122:     };
  123: 
  124:     // Save weekly routines with order
  125:     document.querySelectorAll('.day-column').forEach(dayColumn => {
  126:         const dayValue = dayColumn.dataset.dayValue;
  127:         state.weeklyRoutines[dayValue] = [];
  128:         dayColumn.querySelectorAll('.routine-chip').forEach((chip, index) => {
  129:             state.weeklyRoutines[dayValue].push({
  130:                 routine_id: chip.dataset.routineId,
  131:                 name: chip.dataset.routineName || chip.querySelector('span').textContent,
  132:                 order: index + 1
  133:             });
  134:         });
  135:     });
  136: 
  137:     // Save sequential routines
  138:     document.querySelectorAll('.program-routine-row').forEach(row => {
  139:         const routineIdInput = row.querySelector('input[name*="_routine_id"]');
  140:         const routineNameInput = row.querySelector('input[type="text"][readonly]');
  141:         const orderInput = row.querySelector('input[name*="_order"]');
  142: 
  143:         if (routineIdInput && routineNameInput) {
  144:             state.sequentialRoutines.push({
  145:                 routine_id: routineIdInput.value,
  146:                 name: routineNameInput.value,
  147:                 order: orderInput ? orderInput.value : state.sequentialRoutines.length + 1
  148:             });
  149:         }
  150:     });
  151: 
  152:     return state;
  153: }
  154: 
  155: function restoreProgramState(state) {
  156:     if (!state) return;
  157: 
  158:     // Restore scheduling type
  159:     if (state.schedulingType === 'weekly') {
  160:         document.getElementById('scheduling-weekly').checked = true;
  161:     } else {
  162:         document.getElementById('scheduling-sequential').checked = true;
  163:     }
  164: 
  165:     // Clear current routines
  166:     document.querySelectorAll('.routines-for-day-container').forEach(container => {
  167:         container.innerHTML = '';
  168:     });
  169:     document.getElementById('program-routines-container').innerHTML = '';
  170: 
  171:     // Restore weekly routines
  172:     Object.keys(state.weeklyRoutines).forEach(dayValue => {
  173:         const dayColumn = document.querySelector(`.day-column[data-day-value="${dayValue}"]`);
  174:         if (dayColumn) {
  175:             const container = dayColumn.querySelector('.routines-for-day-container');
  176:             state.weeklyRoutines[dayValue].forEach(routine => {
  177:                 const chip = document.createElement('div');
  178:                 chip.className = 'routine-chip';
  179:                 chip.draggable = true;
  180:                 chip.dataset.routineId = routine.routine_id || routine.id;
  181:                 chip.dataset.routineName = routine.name;
  182:                 chip.innerHTML = `
  183:                     <span class="routine-chip-label">${routine.name}</span>
  184:                     <div class="d-flex align-items-center">
  185:                         <button type="button" class="btn-close btn-close-white btn-sm" data-ignore-double-activate="true" aria-label="Remove"></button>
  186:                     </div>
  187:                     <input type="hidden" name="weekly_day_${dayValue}_routines" value="${routine.routine_id || routine.id}">
  188:                 `;
  189:                 container.appendChild(chip);
  190:                 setupProgramRoutineDragListeners(chip);
  191:             });
  192:         }
  193:     });
  194: 
  195:     // Restore sequential routines
  196:     const programRoutinesContainer = document.getElementById('program-routines-container');
  197:     const template = document.getElementById('program-routine-template');
  198: 
  199:     state.sequentialRoutines.forEach((routine, index) => {
  200:         if (template) {
  201:             let newRowHTML = template.innerHTML;
  202:             newRowHTML = newRowHTML.replace(/__INDEX__/g, index)
  203:                                    .replace(/__ROUTINE_ID__/g, routine.routine_id || routine.id)
  204:                                    .replace(/__ROUTINE_NAME__/g, routine.name)
  205:                                    .replace(/__ORDER__/g, routine.order);
  206: 
  207:             const tempDiv = document.createElement('div');
  208:             tempDiv.innerHTML = newRowHTML;
  209:             const newRow = tempDiv.firstElementChild;
  210: 
  211:             programRoutinesContainer.appendChild(newRow);
  212:             setupSequentialRoutineActivation(newRow);
  213:         }
  214:     });
  215: 
  216:     // Update UI visibility
  217:     const weeklyContainer = document.getElementById('weekly-schedule-container');
  218:     const sequentialContainer = document.getElementById('sequential-schedule-container');
  219:     const sequentialAdder = document.getElementById('sequential-routine-adder');
  220: 
  221:     if (state.schedulingType === 'weekly') {
  222:         weeklyContainer.style.display = 'block';
  223:         sequentialContainer.style.display = 'none';
  224:         sequentialAdder.style.display = 'none';
  225:         initializeProgramRoutinesDragDrop();
  226:     } else {
  227:         weeklyContainer.style.display = 'none';
  228:         sequentialContainer.style.display = 'block';
  229:         sequentialAdder.style.display = 'block';
  230:     }
  231: }
  232: 
  233: async function restoreProgramStateViaAPI(programId, originalState) {
  234:     try {
  235:         const response = await fetch(`/ajax/program/${programId}/restore-state/`, {
  236:             method: 'POST',
  237:             headers: {
  238:                 'Content-Type': 'application/json',
  239:                 'X-CSRFToken': getCsrfToken()
  240:             },
  241:             body: JSON.stringify({
  242:                 original_state: originalState
  243:             })
  244:         });
  245: 
  246:         if (!response.ok) {
  247:             throw new Error('Failed to restore program state');
  248:         }
  249: 
  250:         const data = await response.json();
  251:         if (data.success) {
  252:             console.log('Program state restored successfully');
  253:             return true;
  254:         } else {
  255:             console.error('Error restoring program state:', data.error);
  256:             return false;
  257:         }
  258:     } catch (error) {
  259:         console.error('Error restoring program state:', error);
  260:         return false;
  261:     }
  262: }
  263: 
  264: async function toggleScheduleType() {
  265:     const weeklyContainer = document.getElementById('weekly-schedule-container');
  266:     const sequentialContainer = document.getElementById('sequential-schedule-container');
  267:     const sequentialAdder = document.getElementById('sequential-routine-adder');
  268:     const weeklyRadio = document.getElementById('scheduling-weekly');
  269:     const programRoutinesContainer = document.getElementById('program-routines-container');
  270: 
  271:     if (!weeklyContainer || !sequentialContainer || !sequentialAdder || !weeklyRadio) return;
  272: 
  273:     // Get program ID first
  274:     const programForm = document.querySelector('form[action*="/programs/"]');
  275:     let programId = null;
  276:     if (programForm) {
  277:         const actionUrl = programForm.getAttribute('action');
  278:         const match = actionUrl.match(/\/programs\/(\d+)\//);
  279:         if (match) {
  280:             programId = match[1];
  281:         }
  282:     }
  283: 
  284:     // Prepare routine data to send to backend
  285:     let routineData = null;
  286:     const schedulingType = weeklyRadio.checked ? 'weekly' : 'sequential';
  287: 
  288:     if (weeklyRadio.checked) {
  289:         // Switching TO weekly - collect from sequential view first
  290:         const sequentialRoutines = [];
  291:         programRoutinesContainer?.querySelectorAll('.program-routine-row').forEach((row) => {
  292:             const routineIdInput = row.querySelector('input[name*="_routine_id"]');
  293:             const routineNameInput = row.querySelector('input[type="text"][readonly]');
  294: 
  295:             if (routineIdInput && routineNameInput && routineIdInput.value) {
  296:                 sequentialRoutines.push({
  297:                     routine_id: routineIdInput.value,
  298:                     name: routineNameInput.value
  299:                 });
  300:             }
  301:         });
  302: 
  303:         // Distribute sequential routines to weekly days
  304:         const days = [0, 1, 2, 3, 4, 5, 6];
  305:         routineData = {};
  306:         sequentialRoutines.forEach((routine, index) => {
  307:             const assignedDay = days[index % days.length];
  308:             if (!routineData[assignedDay]) {
  309:                 routineData[assignedDay] = [];
  310:             }
  311:             routineData[assignedDay].push(routine);
  312:         });
  313: 
  314:         // Save to database first if we have a program ID
  315:         if (programId) {
  316:             try {
  317:                 const response = await fetch(`/ajax/program/${programId}/update-scheduling/`, {
  318:                     method: 'POST',
  319:                     headers: {
  320:                         'Content-Type': 'application/json',
  321:                         'X-CSRFToken': getCsrfToken()
  322:                     },
  323:                     body: JSON.stringify({
  324:                         scheduling_type: 'weekly',
  325:                         routines: routineData
  326:                     })
  327:                 });
  328: 
  329:                 const data = await response.json();
  330:                 if (!data.success) {
  331:                     console.error('Error updating scheduling type:', data.error);
  332:                     return;
  333:                 }
  334:             } catch (error) {
  335:                 console.error('Error updating scheduling type:', error);
  336:                 return;
  337:             }
  338:         }
  339: 
  340:         // Now update the DOM
  341:         // Clear sequential container
  342:         programRoutinesContainer.innerHTML = '';
  343: 
  344:         // Clear weekly containers first to avoid duplicates
  345:         weeklyContainer.querySelectorAll('.routines-for-day-container').forEach(container => {
  346:             container.innerHTML = '';
  347:         });
  348: 
  349:         // Add to weekly view
  350:         Object.entries(routineData).forEach(([day, routines]) => {
  351:             const dayColumn = weeklyContainer.querySelector(`.day-column[data-day-value="${day}"]`);
  352:             if (dayColumn) {
  353:                 const routinesContainer = dayColumn.querySelector('.routines-for-day-container');
  354: 
  355:                 routines.forEach(routine => {
  356:                     const chip = document.createElement('div');
  357:                     chip.className = 'routine-chip';
  358:                     chip.draggable = true;
  359:                     chip.dataset.routineId = routine.routine_id;
  360:                     chip.dataset.routineName = routine.name;
  361:                     chip.innerHTML = `
  362:                         <span class="routine-chip-label">${routine.name}</span>
  363:                         <div class="d-flex align-items-center">
  364:                             <button type="button" class="btn-close btn-close-white btn-sm" data-ignore-double-activate="true" aria-label="Remove"></button>
  365:                         </div>
  366:                         <input type="hidden" name="weekly_day_${day}_routines" value="${routine.routine_id}">
  367:                     `;
  368: 
  369:                     routinesContainer.appendChild(chip);
  370:                     setupProgramRoutineDragListeners(chip);
  371:                 });
  372:             }
  373:         });
  374: 
  375:         weeklyContainer.style.display = 'block';
  376:         sequentialContainer.style.display = 'none';
  377:         sequentialAdder.style.display = 'none';
  378:         initializeProgramRoutinesDragDrop();
  379: 
  380:     } else {
  381:         // Switching TO sequential - collect from weekly view first
  382:         routineData = [];
  383: 
  384:         for (let day = 0; day < 7; day++) {
  385:             const dayColumn = weeklyContainer.querySelector(`.day-column[data-day-value="${day}"]`);
  386:             if (dayColumn) {
  387:                 dayColumn.querySelectorAll('.routine-chip').forEach(chip => {
  388:                     const routineId = chip.dataset.routineId;
  389:                     const routineName = chip.dataset.routineName || chip.querySelector('span').textContent;
  390:                     if (routineId) {
  391:                         routineData.push({
  392:                             routine_id: routineId,
  393:                             name: routineName
  394:                         });
  395:                     }
  396:                 });
  397:             }
  398:         }
  399: 
  400:         // Save to database first if we have a program ID
  401:         if (programId) {
  402:             try {
  403:                 const response = await fetch(`/ajax/program/${programId}/update-scheduling/`, {
  404:                     method: 'POST',
  405:                     headers: {
  406:                         'Content-Type': 'application/json',
  407:                         'X-CSRFToken': getCsrfToken()
  408:                     },
  409:                     body: JSON.stringify({
  410:                         scheduling_type: 'sequential',
  411:                         routines: routineData
  412:                     })
  413:                 });
  414: 
  415:                 const data = await response.json();
  416:                 if (!data.success) {
  417:                     console.error('Error updating scheduling type:', data.error);
  418:                     return;
  419:                 }
  420:             } catch (error) {
  421:                 console.error('Error updating scheduling type:', error);
  422:                 return;
  423:             }
  424:         }
  425: 
  426:         // Now update the DOM
  427:         // Clear weekly view
  428:         weeklyContainer.querySelectorAll('.routines-for-day-container').forEach(container => {
  429:             container.innerHTML = '';
  430:         });
  431: 
  432:         // Clear sequential first
  433:         programRoutinesContainer.innerHTML = '';
  434: 
  435:         // Add to sequential view
  436:         routineData.forEach((routine, index) => {
  437:             const template = document.getElementById('program-routine-template');
  438:             if (template) {
  439:                 let newRowHTML = template.innerHTML;
  440:                 newRowHTML = newRowHTML.replace(/__INDEX__/g, index)
  441:                                        .replace(/__ROUTINE_ID__/g, routine.routine_id)
  442:                                        .replace(/__ROUTINE_NAME__/g, routine.name)
  443:                                        .replace(/__ORDER__/g, index + 1);
  444: 
  445:                 const tempDiv = document.createElement('div');
  446:                 tempDiv.innerHTML = newRowHTML;
  447:                 const newRow = tempDiv.firstElementChild;
  448: 
  449:                 programRoutinesContainer.appendChild(newRow);
  450:             }
  451:         });
  452: 
  453:         weeklyContainer.style.display = 'none';
  454:         sequentialContainer.style.display = 'block';
  455:         sequentialAdder.style.display = 'block';
  456:     }
  457: }
  458: 
  459: // ======================================
  460: //      HTTP REQUEST HELPER (Optional)
  461: // ======================================
  462: // This can be called by functions triggered via data-function if they need to make API calls.
  463: async function httpRequestHelper(url, method = 'GET', bodyData = null, headers = {}) {
  464:     const csrfToken = getCsrfToken();
  465:     const defaultHeaders = {
  466:         'X-CSRFToken': csrfToken,
  467:         'Accept': 'application/json',
  468:     };
  469:     let body = null;
  470: 
  471:     if (bodyData && method.toUpperCase() !== 'GET') {
  472:         defaultHeaders['Content-Type'] = 'application/json';
  473:         body = JSON.stringify(bodyData);
  474:     }
  475: 
  476:     const finalHeaders = { ...defaultHeaders, ...headers };
  477: 
  478:     try {
  479:         const res = await fetch(url, {
  480:             method: method.toUpperCase(),
  481:             headers: finalHeaders,
  482:             body
  483:         });
  484: 
  485:         // Attempt to parse JSON, fall back to text if needed or if no content
  486:         let responseData = null;
  487:         const contentType = res.headers.get("content-type");
  488:         if (contentType && contentType.includes("application/json")) {
  489:              try {
  490:                 responseData = await res.json();
  491:              } catch (e) { /* ignore json parsing error if body is empty */ }
  492:         } else {
  493:              try {
  494:                 responseData = await res.text();
  495:              } catch(e) { /* ignore text parsing error */ }
  496:         }
  497: 
  498:         return {
  499:             ok: res.ok,
  500:             status: res.status,
  501:             statusText: res.statusText,
  502:             data: responseData,
  503:             headers: res.headers
  504:         };
  505: 
  506:     } catch (error) {
  507:         console.error('Fetch error:', error);
  508:         return {
  509:             ok: false,
  510:             status: 0, // Indicate network error
  511:             statusText: 'Network Error',
  512:             data: { detail: 'Network error. Please check your connection.' },
  513:             error: error
  514:         };
  515:     }
  516: }
  517: 
  518: 
  519: // ======================================
  520: //          MODAL FUNCTIONS
  521: // ======================================
  522: 
  523: function show_modal(event) {
  524:     const modalname = event.target.getAttribute('data-modal-name');
  525:     const modal = document.getElementById(modalname);
  526:     if (modal) {
  527:         const form = modal.querySelector('form');
  528:         if(form && form.id) clearFormErrors(form.id);
  529: 
  530:         // Reset the form for add exercise modal
  531:         if (modalname === 'add-exercise-modal') {
  532:             // Reset title
  533:             const modalTitle = document.getElementById('exercise-modal-title');
  534:             if (modalTitle) modalTitle.textContent = 'Add New Exercise';
  535: 
  536:             // Clear exercise ID
  537:             const exerciseIdField = document.getElementById('exercise-id');
  538:             if (exerciseIdField) exerciseIdField.value = '';
  539: 
  540:             // Reset form
  541:             if (form) form.reset();
  542: 
  543:             // Hide delete button
  544:             const deleteBtn = document.getElementById('delete-exercise-btn');
  545:             if (deleteBtn) deleteBtn.style.display = 'none';
  546: 
  547:             // Reset exercise type to default
  548:             const exerciseTypeField = document.getElementById('id_exercise_type_modal');
  549:             if (exerciseTypeField) exerciseTypeField.value = 'accessory';
  550:         }
  551: 
  552:         modal.style.display = 'flex';
  553:     }
  554:     const focus = event.target.getAttribute('data-focus');
  555:     if (focus) {
  556:         setTimeout(() => {
  557:             const elementToFocus = document.getElementById(focus);
  558:              if (elementToFocus) elementToFocus.focus();
  559:         }, 100);
  560:     }
  561: }
  562: 
  563: function close_modal(event) {
  564:     // Logic to close modal by clicking background or close button
  565:      if (event.target.classList.contains('siu-modal') || event.target.closest('.siu-modal-close')) {
  566:         const modal = event.target.closest('.siu-modal');
  567:         // Ensure we didn't click inside content unless it IS the close button
  568:         if (modal && (!event.target.closest('.siu-modal-content') || event.target.closest('.siu-modal-close'))) {
  569:              modal.style.display = 'none';
  570:         }
  571:     }
  572: }
  573: 
  574: // --- Close modal with Escape key ---
  575: document.addEventListener('keydown', (event) => {
  576:     if (event.key === "Escape") {
  577:         document.querySelectorAll('.siu-modal[style*="display: flex"]').forEach(modal => {
  578:             modal.style.display = 'none';
  579:         });
  580:     }
  581: });
  582: 
  583: // ======================================
  584: //          UI UTILITIES
  585: // ======================================
  586: 
  587: function getCookie(name) {
  588:     let cookieValue = null;
  589:     if (document.cookie && document.cookie !== '') {
  590:         const cookies = document.cookie.split(';');
  591:         for (let i = 0; i < cookies.length; i++) {
  592:             const cookie = cookies[i].trim();
  593:             // Does this cookie string begin with the name we want?
  594:             if (cookie.substring(0, name.length + 1) === (name + '=')) {
  595:                 cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
  596:                 break;
  597:             }
  598:         }
  599:     }
  600:     return cookieValue;
  601: }
  602: 
  603: function getCsrfToken() {
  604:     let token = document.querySelector('meta[name="csrf-token"]');
  605:     if (token) return token.content;
  606:     token = document.querySelector('[name=csrfmiddlewaretoken]');
  607:     if (token) return token.value;
  608:     // Fallback to cookie
  609:     token = getCookie('csrftoken');
  610:     if (token) return token;
  611:     console.error('CSRF token not found');
  612:     return null;
  613: }
  614: 
  615: function send_toast(body, status = 'default', title = '', delete_time = 3000) {
  616:     const alertConfigs = {
  617:         success: { icon: 'fas fa-check-circle', alertClass: 'alert-success' },
  618:         danger: { icon: 'fas fa-exclamation-triangle', alertClass: 'alert-danger' },
  619:         warning: { icon: 'fas fa-exclamation-triangle', alertClass: 'alert-warning' },
  620:         info: { icon: 'fas fa-info-circle', alertClass: 'alert-info' },
  621:         default: { icon: 'fas fa-info-circle', alertClass: 'alert-primary' },
  622:     };
  623:     const { icon, alertClass } = alertConfigs[status] || alertConfigs.default;
  624:     let toast_container = document.querySelector(".toast-container");
  625:     if (!toast_container) {
  626:         console.warn("Toast container not found. Creating one.");
  627:         toast_container = document.createElement('div');
  628:         toast_container.className = 'toast-container position-fixed top-0 end-0 p-3';
  629:         toast_container.style.zIndex = '1100';
  630:         document.body.appendChild(toast_container);
  631:     }
  632:     let toast = document.createElement('div');
  633:     toast.className = `toast align-items-center ${alertClass} border-0 show`;
  634:     toast.setAttribute('role', 'alert');
  635:     toast.setAttribute('aria-live', 'assertive');
  636:     toast.setAttribute('aria-atomic', 'true');
  637:     toast.style.pointerEvents = 'auto';
  638:     toast.innerHTML = `
  639:         <div class="d-flex">
  640:             <div class="toast-body">
  641:                 ${title ? `<strong class="me-auto"><i class="${icon}"></i> ${title}</strong><p class="mb-0">${body}</p>` : `<i class="${icon}"></i> ${body}`}
  642:             </div>
  643:             <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close" onclick="this.closest('.toast').remove()"></button>
  644:         </div>
  645:     `;
  646:     toast_container.appendChild(toast);
  647:     setTimeout(() => {
  648:         const bsToast = bootstrap?.Toast?.getInstance(toast);
  649:         if (bsToast) {
  650:             bsToast.hide();
  651:              toast.addEventListener('hidden.bs.toast', () => toast.remove());
  652:         } else {
  653:             toast.remove();
  654:         }
  655:     }, delete_time);
  656: }
  657: 
  658: function displayFormErrors(formId, errors) {
  659:     const form = document.getElementById(formId);
  660:     if (!form) return;
  661:     // Use the specific error div ID for workouts modal, or fallback to generic
  662:     const generalErrorDivId = formId === 'add-workout-form' ? 'form-errors-workout' : 'form-errors';
  663:     const generalErrorDiv = form.querySelector(`#${generalErrorDivId}`);
  664:     let firstFieldWithError = null;
  665:     if (generalErrorDiv) {
  666:         generalErrorDiv.innerHTML = '';
  667:         generalErrorDiv.style.display = 'none';
  668:     }
  669:     const nonFieldDetail = errors.non_field_errors || (errors.detail ? [errors.detail] : []);
  670:      if (nonFieldDetail.length > 0 && generalErrorDiv) {
  671:         generalErrorDiv.innerHTML = nonFieldDetail.join('<br>');
  672:         generalErrorDiv.style.display = 'block';
  673:     }
  674:     for (const field in errors) {
  675:         if (field !== 'non_field_errors' && field !== 'detail') {
  676:             const errorDiv = form.querySelector(`#error-${field}`);
  677:             const inputField = form.querySelector(`[name=${field}]`);
  678:             if (errorDiv) {
  679:                 errorDiv.textContent = Array.isArray(errors[field]) ? errors[field].join(' ') : errors[field];
  680:                 errorDiv.style.display = 'block';
  681:                 if (!firstFieldWithError) firstFieldWithError = inputField;
  682:             }
  683:             if (inputField) {
  684:                 inputField.classList.add('is-invalid');
  685:                  if (errorDiv && errorDiv.id) {
  686:                     inputField.setAttribute('aria-describedby', errorDiv.id);
  687:                  }
  688:             }
  689:         }
  690:     }
  691:      if (firstFieldWithError) {
  692:          firstFieldWithError.focus();
  693:      }
  694: }
  695: 
  696: function clearFormErrors(formId) {
  697:     const form = document.getElementById(formId);
  698:     if (!form) return;
  699: 
  700:     // Clear general errors
  701:     const generalErrorDiv = form.querySelector('#form-errors');
  702:     if (generalErrorDiv) {
  703:         generalErrorDiv.innerHTML = '';
  704:         generalErrorDiv.style.display = 'none';
  705:     }
  706: 
  707:     // Clear field-specific errors and remove invalid classes
  708:     const errorMessages = form.querySelectorAll('.invalid-feedback');
  709:     errorMessages.forEach(errorDiv => {
  710:         errorDiv.textContent = '';
  711:         errorDiv.style.display = 'none';
  712:     });
  713: 
  714:     const invalidInputs = form.querySelectorAll('.is-invalid');
  715:     invalidInputs.forEach(input => {
  716:         input.classList.remove('is-invalid');
  717:     });
  718: }
  719: 
  720: // ======================================
  721: //      APPLICATION-SPECIFIC FUNCTIONS
  722: // ======================================
  723: 
  724: // UI update function using httpRequestHelper
  725: window.handle_and_morph = async function(event) { // Made async to use await with httpRequestHelper
  726:     if (event.type === 'keydown' && event.key !== 'Enter') {
  727:         return;
  728:     }
  729:     event.preventDefault();
  730: 
  731:     const element = event.currentTarget;
  732:     let endpoint = element.getAttribute('data-routing');
  733:     const targetSelector = element.getAttribute('data-target');
  734: 
  735:     if (!endpoint) {
  736:         console.error('handle_and_morph: data-routing attribute is missing on element:', element);
  737:         send_toast('Configuration error: Missing routing.', 'danger', 'Error');
  738:         return;
  739:     }
  740: 
  741:     // Construct URL with query parameters from data-* attributes
  742:     const params = new URLSearchParams();
  743:     for (const dataAttr in element.dataset) {
  744:         // data-routing and data-target are for control, others are params
  745:         // data-function is also for control
  746:         if (dataAttr !== 'routing' && dataAttr !== 'target' && dataAttr !== 'function') {
  747:             params.append(dataAttr, element.dataset[dataAttr]);
  748:         }
  749:     }
  750:     if (params.toString()) {
  751:         endpoint += (endpoint.includes('?') ? '&' : '?') + params.toString();
  752:     }
  753: 
  754:     console.log(`handle_and_morph: HTTP GET to "${endpoint}" for target "${targetSelector || 'none'}"`);
  755: 
  756:     try {
  757:         // showLoading(); // Optional: if you have a generic AJAX loading indicator
  758:         const response = await httpRequestHelper(endpoint, 'GET');
  759:         // hideLoading(); // Optional
  760:         console.log('handle_and_morph received HTTP response:', response);
  761: 
  762:         if (!response.ok) {
  763:             const errorDetail = response.data?.detail || response.data?.error || response.statusText || 'An error occurred.';
  764:             console.error('Error from backend in handle_and_morph:', errorDetail, response);
  765:             send_toast(errorDetail, 'danger', 'Server Error');
  766:             // If the server provides HTML in the error response for the target, display it
  767:             if (targetSelector && response.data?.html) {
  768:                  const targetElement = document.querySelector(targetSelector);
  769:                  if (targetElement) targetElement.innerHTML = response.data.html;
  770:             }
  771:             return;
  772:         }
  773: 
  774:         if (targetSelector && response.data && response.data.html !== undefined) {
  775:             const targetElement = document.querySelector(targetSelector);
  776:             if (targetElement) {
  777:                 targetElement.innerHTML = response.data.html;
  778:             } else {
  779:                 console.warn(`handle_and_morph: Target element "${targetSelector}" not found.`);
  780:                 send_toast(`UI update error: Target '${targetSelector}' not found.`, 'warning', 'Client Error');
  781:             }
  782:         } else if (targetSelector && (!response.data || response.data.html === undefined)) {
  783:             console.warn(`handle_and_morph: No HTML content provided in response for target "${targetSelector}". Response:`, response);
  784:         }
  785: 
  786:         // Handle toast messages from response.data if structured accordingly
  787:         if (response.data && response.data.toast) {
  788:             const toast = response.data.toast;
  789:             send_toast(toast.body, toast.status || 'info', toast.title || '');
  790:         }
  791: 
  792:     } catch (error) {
  793:         // hideLoading(); // Optional: ensure loading is hidden on error
  794:         // This catch handles errors from httpRequestHelper itself (e.g., network errors)
  795:         console.error('Error in httpRequestHelper call for handle_and_morph:', error);
  796:         const message = error.data?.detail || error.message || 'Error processing action.';
  797:         send_toast(message, 'danger', 'Request Failed');
  798:     }
  799: };
  800: 
  801: // --- Add/Edit Exercise Modal Submission ---
  802: // This function will be triggered by data-function="click->saveExercise"
  803: async function saveExercise(event) {
  804:     const form = event.target.closest('form');
  805:     if (!form) return;
  806:     const formId = form.id;
  807:     clearFormErrors(formId);
  808: 
  809:     const exerciseId = document.getElementById('exercise-id').value;
  810:     const isEdit = exerciseId !== '';
  811: 
  812:     const formData = new FormData(form);
  813:     const data = {};
  814:     formData.forEach((value, key) => {
  815:         const inputElement = form.querySelector(`[name="${key}"]`);
  816:         if (inputElement && inputElement.tagName === 'SELECT' && inputElement.multiple) {
  817:             // Always get all for multi-select
  818:             if (!data[key]) data[key] = []; // Initialize if not exists
  819:             data[key] = formData.getAll(key);
  820:         } else if (data.hasOwnProperty(key)) {
  821:             // Handle multiple non-multi-select (e.g., checkboxes)
  822:             if (!Array.isArray(data[key])) data[key] = [data[key]];
  823:             data[key].push(value);
  824:         } else {
  825:             data[key] = value;
  826:         }
  827:     });
  828:     data.is_custom = true; // Always set for this form
  829: 
  830:     // Determine URL and method based on whether we're editing or creating
  831:     const url = isEdit ? `/api/exercises/${exerciseId}/` : form.action;
  832:     const method = isEdit ? 'PUT' : 'POST';
  833: 
  834:     // Use the helper for the actual request
  835:     const response = await httpRequestHelper(url, method, data);
  836: 
  837:     if (response.ok) {
  838:         const message = isEdit ? 'Exercise updated successfully!' : 'Exercise added successfully!';
  839:         send_toast(message, 'success');
  840:         const modal = form.closest('.siu-modal');
  841:         if (modal) modal.style.display = 'none';
  842:         form.reset();
  843:         document.getElementById('exercise-id').value = '';
  844:         // Instead of full reload, maybe update list dynamically later?
  845:         // For now, reload is simplest
  846:         window.location.reload();
  847:     } else {
  848:         displayFormErrors(formId, response.data || { detail: response.statusText });
  849:         send_toast(response.data?.detail || 'Error saving exercise.', 'danger');
  850:     }
  851: }
  852: 
  853: // --- Edit Exercise ---
  854: // This function opens the modal with pre-filled data for editing
  855: function editExercise(event) {
  856:     const exerciseCard = event.currentTarget;
  857: 
  858:     // Get the exercise data from data attributes
  859:     const exerciseId = exerciseCard.dataset.exerciseId;
  860:     const exerciseName = exerciseCard.dataset.exerciseName;
  861:     const exerciseDescription = exerciseCard.dataset.exerciseDescription || '';
  862:     const exerciseType = exerciseCard.dataset.exerciseType;
  863:     const exerciseCategories = exerciseCard.dataset.exerciseCategories ?
  864:         exerciseCard.dataset.exerciseCategories.split(',') : [];
  865: 
  866:     // Update modal title
  867:     document.getElementById('exercise-modal-title').textContent = 'Edit Exercise';
  868: 
  869:     // Fill the form fields
  870:     document.getElementById('exercise-id').value = exerciseId;
  871:     document.getElementById('id_name_modal').value = exerciseName;
  872:     document.getElementById('id_description_modal').value = exerciseDescription;
  873:     document.getElementById('id_exercise_type_modal').value = exerciseType;
  874: 
  875:     // Set selected categories
  876:     const categorySelect = document.getElementById('id_categories_modal');
  877:     Array.from(categorySelect.options).forEach(option => {
  878:         option.selected = exerciseCategories.includes(option.value);
  879:     });
  880: 
  881:     // Show delete button for editing
  882:     document.getElementById('delete-exercise-btn').style.display = 'inline-block';
  883: 
  884:     // Open the modal
  885:     document.getElementById('add-exercise-modal').style.display = 'block';
  886: 
  887:     // Focus on the name field
  888:     document.getElementById('id_name_modal').focus();
  889: }
  890: 
  891: // --- Delete Exercise ---
  892: // This function deletes a custom exercise
  893: async function deleteExercise(event) {
  894:     const exerciseId = document.getElementById('exercise-id').value;
  895: 
  896:     if (!exerciseId) {
  897:         send_toast('No exercise selected for deletion.', 'danger');
  898:         return;
  899:     }
  900: 
  901:     if (!confirm('Are you sure you want to delete this exercise? This cannot be undone.')) {
  902:         return;
  903:     }
  904: 
  905:     const response = await httpRequestHelper(`/api/exercises/${exerciseId}/`, 'DELETE');
  906: 
  907:     if (response.ok) {
  908:         send_toast('Exercise deleted successfully!', 'success');
  909:         const modal = document.getElementById('add-exercise-modal');
  910:         if (modal) modal.style.display = 'none';
  911:         document.getElementById('add-exercise-form').reset();
  912:         document.getElementById('exercise-id').value = '';
  913:         window.location.reload();
  914:     } else {
  915:         send_toast(response.data?.detail || 'Error deleting exercise.', 'danger');
  916:     }
  917: }
  918: 
  919: 
  920: // --- Update Set ---
  921: // Triggered by data-function="blur->updateSet" or data-function="change->updateSet"
  922: // Needs data-set-id, data-field on the input/select element
  923: async function updateSet(eventOrElement, overrideValue) {
  924:     const element = eventOrElement && eventOrElement.target ? eventOrElement.target : eventOrElement;
  925:     if (!element) {
  926:         return false;
  927:     }
  928: 
  929:     const setId = element.dataset.setId;
  930:     const field = element.dataset.field;
  931: 
  932:     if (!setId || !field) {
  933:         console.error('Missing data-set-id or data-field on element');
  934:         return false;
  935:     }
  936: 
  937:     let value;
  938:     if (overrideValue !== undefined) {
  939:         value = overrideValue;
  940:     } else if (field === 'is_warmup') {
  941:         value = element.checked;
  942:     } else {
  943:         value = element.value;
  944:     }
  945: 
  946:     const url = '/api/workouts/sets/' + setId + '/';
  947:     const data = { [field]: value };
  948: 
  949:     const response = await httpRequestHelper(url, 'PATCH', data);
  950: 
  951:     if (response.ok) {
  952:         if (field === 'reps' || field === 'weight') {
  953:             const row = element.closest('.set-row');
  954:             if (row) {
  955:                 row.dataset[field] = value;
  956:             }
  957:         }
  958:         return true;
  959:     }
  960: 
  961:     send_toast(response.data?.detail || 'Error updating set', 'danger');
  962:     return false;
  963: }
  964: 
  965: function normalizeWorkoutSetValue(value, field) {
  966:     if (value === null || value === undefined) {
  967:         return '';
  968:     }
  969:     const trimmed = String(value).trim();
  970:     if (!trimmed) {
  971:         return '';
  972:     }
  973:     if (field === 'weight') {
  974:         const numeric = Number(trimmed);
  975:         return Number.isFinite(numeric) ? numeric : trimmed;
  976:     }
  977:     return trimmed;
  978: }
  979: 
  980: function captureWorkoutSetOriginalValue(event) {
  981:     const element = event?.target;
  982:     if (!element) {
  983:         return;
  984:     }
  985:     const field = element.dataset.field;
  986:     if (field === 'is_warmup') {
  987:         element.dataset.originalValue = element.checked ? 'true' : 'false';
  988:     } else {
  989:         element.dataset.originalValue = element.value ?? '';
  990:     }
  991: }
  992: 
  993: async function handleWorkoutSetChange(event) {
  994:     const element = event?.target;
  995:     if (!element) {
  996:         return;
  997:     }
  998: 
  999:     const field = element.dataset.field;
 1000:     const originalValueRaw = element.dataset.originalValue ?? (field === 'is_warmup' ? (element.checked ? 'true' : 'false') : element.value ?? '');
 1001:     const normalizedOriginal = normalizeWorkoutSetValue(originalValueRaw, field);
 1002: 
 1003:     const success = await updateSet(element);
 1004:     if (!success) {
 1005:         return;
 1006:     }
 1007: 
 1008:     const newValueRaw = field === 'is_warmup' ? (element.checked ? 'true' : 'false') : element.value ?? '';
 1009:     element.dataset.originalValue = newValueRaw;
 1010: 
 1011:     if ((field !== 'reps' && field !== 'weight') || normalizeWorkoutSetValue(newValueRaw, field) === normalizedOriginal) {
 1012:         return;
 1013:     }
 1014: 
 1015:     const setsContainer = element.closest('.sets-container');
 1016:     if (!setsContainer) {
 1017:         return;
 1018:     }
 1019: 
 1020:     const inputs = setsContainer.querySelectorAll('[data-field="' + field + '"]');
 1021:     for (const other of inputs) {
 1022:         if (other === element) {
 1023:             continue;
 1024:         }
 1025:         const otherOriginalValue = other.value ?? '';
 1026:         if (normalizeWorkoutSetValue(otherOriginalValue, field) !== normalizedOriginal) {
 1027:             continue;
 1028:         }
 1029: 
 1030:         other.value = element.value;
 1031:         const updated = await updateSet(other, element.value);
 1032:         if (updated) {
 1033:             other.dataset.originalValue = newValueRaw;
 1034:         } else {
 1035:             other.value = otherOriginalValue;
 1036:         }
 1037:     }
 1038: }
 1039: 
 1040: // --- Add Set to Exercise ---
 1041: // Triggered by data-function="click->addSet"
 1042: // Copies values from the last set or uses smart defaults
 1043: async function addSet(event) {
 1044:     event.preventDefault();
 1045:     const button = event.currentTarget;
 1046:     const exerciseId = button.dataset.exerciseId;
 1047: 
 1048:     if (!exerciseId) {
 1049:         console.error('Missing data-exercise-id on add set button');
 1050:         return;
 1051:     }
 1052: 
 1053:     // Find the parent card body and sets container
 1054:     const cardBody = button.closest('.card-body');
 1055:     const setsContainer = cardBody.querySelector('.sets-container');
 1056:     const tbody = setsContainer.querySelector('.sets-tbody');
 1057: 
 1058:     // Get default values from last set and calculate set number
 1059:     let reps = 0;
 1060:     let weight = 0;
 1061:     let isWarmup = false;
 1062:     let setNumber = 1;
 1063: 
 1064:     if (tbody) {
 1065:         // Count existing sets to determine next set number
 1066:         const existingRows = tbody.querySelectorAll('.set-row');
 1067:         setNumber = existingRows.length + 1;
 1068: 
 1069:         // Get the last set row
 1070:         const lastRow = tbody.querySelector('.set-row:last-child');
 1071:         if (lastRow) {
 1072:             // Copy values from last set
 1073:             reps = parseInt(lastRow.dataset.reps) || parseInt(lastRow.querySelector('.set-reps-input')?.value) || 0;
 1074:             weight = parseFloat(lastRow.dataset.weight) || parseFloat(lastRow.querySelector('.set-weight-input')?.value) || 0;
 1075:             // Last set is usually not a warmup
 1076:             isWarmup = false;
 1077:         }
 1078:     }
 1079: 
 1080:     // If still no values, try to get from previous workout with same exercise
 1081:     // This would require an API call to get historical data - for now use defaults
 1082:     if (reps === 0) {
 1083:         reps = 10; // Default reps
 1084:         weight = 0; // Default weight
 1085:     }
 1086: 
 1087:     // Ensure reps is at least 1 (PositiveIntegerField in Django)
 1088:     if (reps < 1) {
 1089:         reps = 1;
 1090:     }
 1091: 
 1092:     const url = `/api/workouts/exercises/${exerciseId}/sets/`;
 1093:     const data = {
 1094:         set_number: setNumber,
 1095:         reps: Math.max(1, reps), // Ensure at least 1
 1096:         weight: weight.toFixed(2), // Format as decimal string
 1097:         is_warmup: isWarmup
 1098:     };
 1099: 
 1100:     console.log('Adding set with data:', data, 'to URL:', url);
 1101:     const response = await httpRequestHelper(url, 'POST', data);
 1102:     console.log('Add set response:', response);
 1103: 
 1104:     if (response.ok) {
 1105:         send_toast('Set added', 'success');
 1106: 
 1107:         // Auto-start timer based on user preferences
 1108:         if (window.handleTimerAutoStart) {
 1109:             await window.handleTimerAutoStart(button);
 1110:         }
 1111: 
 1112:         // No inputs to clear since we're using a simple + button
 1113: 
 1114:         // Re-find tbody since we may have created the table structure
 1115:         let tbody = setsContainer.querySelector('.sets-tbody');
 1116: 
 1117:         // If no table exists yet (first set), create the table structure
 1118:         if (!tbody) {
 1119:             const noSetsMessage = setsContainer.querySelector('.no-sets-message');
 1120:             if (noSetsMessage) {
 1121:                 noSetsMessage.remove();
 1122:             }
 1123: 
 1124:             const tableHtml = `
 1125:                 <div class="table-responsive">
 1126:                     <table class="table table-sm table-striped">
 1127:                         <thead>
 1128:                             <tr>
 1129:                                 <th class="set-header-reps">Reps</th>
 1130:                                 <th class="set-header-weight">Weight</th>
 1131:                                 <th class="set-header-warmup">Warmup</th>
 1132:                                 <th class="set-header-done">Done</th>
 1133:                                 <th class="set-header-actions"></th>
 1134:                             </tr>
 1135:                         </thead>
 1136:                         <tbody class="sets-tbody"></tbody>
 1137:                     </table>
 1138:                 </div>
 1139:             `;
 1140: 
 1141:             // Insert the table before the add button (which is in a mt-2 div)
 1142:             const addButton = setsContainer.querySelector('button[data-function*="addSet"]');
 1143:             if (addButton && addButton.parentElement) {
 1144:                 addButton.parentElement.insertAdjacentHTML('beforebegin', tableHtml);
 1145:             } else {
 1146:                 // Fallback: add at the end of the container
 1147:                 setsContainer.insertAdjacentHTML('beforeend', tableHtml);
 1148:             }
 1149:             tbody = setsContainer.querySelector('.sets-tbody');
 1150:         }
 1151: 
 1152:         // Add the new row
 1153:         const setData = response.data;
 1154:         const formattedWeight =
 1155:             setData.weight !== null && setData.weight !== undefined && setData.weight !== ''
 1156:                 ? parseFloat(setData.weight).toFixed(1)
 1157:                 : '';
 1158:         const newRow = `
 1159:             <tr class="set-row${setData.is_completed ? ' set-completed' : ''}" data-set-id="${setData.id}" data-reps="${setData.reps}" data-weight="${formattedWeight}" data-is-completed="${setData.is_completed ? 'true' : 'false'}" data-exercise-id="${exerciseId}">
 1160:                 <td class="set-reps">
 1161:                     <input type="number" class="form-control form-control-sm set-reps-input"
 1162:                            value="${setData.reps}" min="0" step="1"
 1163:                            data-function="blur->updateSet"
 1164:                            data-set-id="${setData.id}"
 1165:                            data-field="reps">
 1166:                 </td>
 1167:                 <td class="set-weight">
 1168:                     <input type="number" class="form-control form-control-sm set-weight-input"
 1169:                            value="${formattedWeight}" min="0" step="0.5"
 1170:                            data-function="blur->updateSet"
 1171:                            data-set-id="${setData.id}"
 1172:                            data-field="weight">
 1173:                 </td>
 1174:                 <td class="set-warmup text-center">
 1175:                     <input type="checkbox" class="form-check-input"
 1176:                            ${setData.is_warmup ? 'checked' : ''}
 1177:                            data-function="change->updateSet"
 1178:                            data-set-id="${setData.id}"
 1179:                            data-field="is_warmup">
 1180:                 </td>
 1181:                 <td class="set-done text-center">
 1182:                     <button type="button" class="btn btn-sm btn-outline-success mark-set-btn"
 1183:                             data-function="click->toggleSetCompletion"
 1184:                             data-set-id="${setData.id}"
 1185:                             data-exercise-id="${exerciseId}"
 1186:                             data-completed="${setData.is_completed ? 'true' : 'false'}"
 1187:                             title="Toggle completion">
 1188:                         <i class="fas fa-check"></i>
 1189:                     </button>
 1190:                 </td>
 1191:                 <td class="set-actions text-center">
 1192:                     <a href="#" class="text-danger"
 1193:                        data-function="click->deleteSet"
 1194:                        data-set-id="${setData.id}"
 1195:                        title="Delete set">
 1196:                         <i class="fas fa-times"></i>
 1197:                     </a>
 1198:                 </td>
 1199:             </tr>
 1200:         `;
 1201:         tbody.insertAdjacentHTML('beforeend', newRow);
 1202: 
 1203:         const insertedRow = tbody.querySelector(`.set-row[data-set-id="${setData.id}"]`);
 1204:         if (insertedRow) {
 1205:             const index = Array.from(tbody.querySelectorAll('.set-row')).indexOf(insertedRow);
 1206:             insertedRow.dataset.setIndex = index;
 1207:         }
 1208: 
 1209:         if (window.mobileSetController && typeof window.mobileSetController.focusSet === 'function') {
 1210:             window.mobileSetController.focusSet(exerciseId, String(setData.id));
 1211:         }
 1212:     } else {
 1213:         console.error('Error adding set:', response);
 1214:         const errorMsg = response.data?.detail || response.data?.error || JSON.stringify(response.data) || 'Error adding set';
 1215:         send_toast(errorMsg, 'danger');
 1216:     }
 1217: }
 1218: 
 1219: // --- Delete Set ---
 1220: // Triggered by data-function="click->deleteSet"
 1221: // Needs data-set-id on the delete link/button
 1222: async function deleteSet(event) {
 1223:     event.preventDefault();
 1224:     const element = event.currentTarget;
 1225:     const setId = element.dataset.setId;
 1226: 
 1227:     if (!setId) {
 1228:         console.error('Missing data-set-id on delete element');
 1229:         return;
 1230:     }
 1231: 
 1232:     const url = `/api/workouts/sets/${setId}/`;
 1233:     const response = await httpRequestHelper(url, 'DELETE');
 1234: 
 1235:     if (response.ok) {
 1236:         send_toast('Set deleted', 'success');
 1237:         const row = element.closest('tr');
 1238:         const tbody = row.closest('tbody');
 1239:         const exerciseId = row?.dataset?.exerciseId;
 1240:         row.remove();
 1241: 
 1242:         // No need to update set numbers since we removed that column
 1243: 
 1244:         // Check if any rows are left
 1245:         const remainingRows = tbody.querySelectorAll('.set-row');
 1246:         if (remainingRows.length === 0) {
 1247:             const table = tbody.closest('.table-responsive');
 1248:             const setsContainer = table.closest('.sets-container');
 1249:             table.remove();
 1250:             const addButton = setsContainer.querySelector('.mt-2');
 1251:             if (addButton) {
 1252:                 addButton.insertAdjacentHTML('beforebegin', '<p class="text-muted no-sets-message">No sets recorded for this exercise.</p>');
 1253:             }
 1254:         }
 1255: 
 1256:         if (exerciseId && window.mobileSetController && typeof window.mobileSetController.advanceSetForExercise === 'function') {
 1257:             window.mobileSetController.advanceSetForExercise(exerciseId);
 1258:         }
 1259:     } else {
 1260:          send_toast(response.data?.detail || 'Error deleting set', 'danger');
 1261:     }
 1262: }
 1263: 
 1264: // --- Toggle Set Completion ---
 1265: // Triggered by data-function="click->toggleSetCompletion"
 1266: // Toggles is_completed flag and updates UI state
 1267: async function toggleSetCompletion(event) {
 1268:     event.preventDefault();
 1269:     const button = event.currentTarget;
 1270:     const setId = button.dataset.setId;
 1271:     const exerciseId = button.dataset.exerciseId;
 1272: 
 1273:     if (!setId) {
 1274:         console.error('Missing data-set-id on completion toggle button');
 1275:         return;
 1276:     }
 1277: 
 1278:     const isCurrentlyCompleted = button.dataset.completed === 'true';
 1279:     const url = `/api/workouts/sets/${setId}/`;
 1280:     const response = await httpRequestHelper(url, 'PATCH', { is_completed: !isCurrentlyCompleted });
 1281: 
 1282:     if (!response.ok) {
 1283:         send_toast(response.data?.detail || 'Error updating set', 'danger');
 1284:         return;
 1285:     }
 1286: 
 1287:     const row = button.closest('.set-row');
 1288:     if (row) {
 1289:         row.dataset.isCompleted = (!isCurrentlyCompleted).toString();
 1290:         row.classList.toggle('set-completed', !isCurrentlyCompleted);
 1291:     }
 1292: 
 1293:     button.dataset.completed = (!isCurrentlyCompleted).toString();
 1294:     if (!isCurrentlyCompleted) {
 1295:         button.classList.remove('btn-outline-success');
 1296:         button.classList.add('btn-success', 'text-white');
 1297:         send_toast('Set marked complete', 'success');
 1298:     } else {
 1299:         button.classList.remove('btn-success', 'text-white');
 1300:         button.classList.add('btn-outline-success');
 1301:         send_toast('Set marked incomplete', 'info');
 1302:     }
 1303: 
 1304:     if (window.mobileSetController && typeof window.mobileSetController.handleSetCompletionChange === 'function') {
 1305:         window.mobileSetController.handleSetCompletionChange({
 1306:             exerciseId: exerciseId,
 1307:             setId: setId,
 1308:             isCompleted: !isCurrentlyCompleted
 1309:         });
 1310:     }
 1311: }
 1312: 
 1313: // --- Update Exercise Feedback ---
 1314: // Triggered by data-function="click->updateExerciseFeedback"
 1315: // Needs data-exercise-id and data-feedback on the button
 1316: async function updateExerciseFeedback(event) {
 1317:     const button = event.currentTarget;
 1318:     const exerciseId = button.dataset.exerciseId;
 1319:     const feedback = button.dataset.feedback;
 1320: 
 1321:     if (!exerciseId || !feedback) {
 1322:         console.error('Missing data-exercise-id or data-feedback on button');
 1323:         return;
 1324:     }
 1325: 
 1326:     // Use PATCH to update just the feedback field
 1327:     const url = `/api/workouts/exercises/${exerciseId}/`;
 1328:     const data = { performance_feedback: feedback };
 1329: 
 1330:     const response = await httpRequestHelper(url, 'PATCH', data);
 1331: 
 1332:     if (response.ok) {
 1333:         // Update button states (robust to both desktop and mobile markup)
 1334:         // Scope to the current card if possible
 1335:         const scope = button.closest('.exercise-card') || button.closest('.workout-exercise-card') || document;
 1336:         const selector = `[data-function*="updateExerciseFeedback"][data-exercise-id="${exerciseId}"]`;
 1337:         const allButtons = scope.querySelectorAll(selector);
 1338: 
 1339:         allButtons.forEach(btn => btn.classList.remove('active'));
 1340:         button.classList.add('active');
 1341: 
 1342:         send_toast(`Feedback saved: ${feedback}`, 'success');
 1343:     } else {
 1344:         console.error('Error updating feedback:', response);
 1345:         send_toast(response.data?.detail || 'Error updating feedback', 'danger');
 1346:     }
 1347: }
 1348: 
 1349: // --- Remove Exercise from Workout ---
 1350: // Triggered by data-function="click->removeExercise"
 1351: // Needs data-exercise-id on the button
 1352: async function removeExercise(event) {
 1353:     const button = event.currentTarget;
 1354:     const exerciseId = button.dataset.exerciseId;
 1355: 
 1356:     if (!exerciseId) {
 1357:         console.error('Missing data-exercise-id on remove button');
 1358:         return;
 1359:     }
 1360: 
 1361:     if (!confirm('Are you sure you want to remove this exercise and all its sets?')) {
 1362:         return;
 1363:     }
 1364: 
 1365:     const url = `/api/workouts/exercises/${exerciseId}/`;
 1366:     const response = await httpRequestHelper(url, 'DELETE');
 1367: 
 1368:     if (response.ok) {
 1369:         send_toast('Exercise removed', 'success');
 1370: 
 1371:         // Stop and clear any timer state for this exercise
 1372:         try {
 1373:             if (window.timerManager) {
 1374:                 window.timerManager.stopTimer(exerciseId);
 1375:             }
 1376:         } catch (e) { /* noop */ }
 1377: 
 1378:         // Prefer removing the full mobile wrapper if present
 1379:         let wrapper = button.closest('.exercise-card');
 1380:         let preferredIndex = null;
 1381:         if (wrapper) {
 1382:             // Remember index before removal
 1383:             preferredIndex = parseInt(wrapper.dataset.exerciseIndex || '0', 10);
 1384:             wrapper.remove();
 1385:         } else {
 1386:             // Desktop or fallback: remove the inner card
 1387:             const innerCard = button.closest('.workout-exercise-card');
 1388:             if (innerCard) innerCard.remove();
 1389:         }
 1390: 
 1391:         // If on mobile view, refresh navigation UI (dots, counter, prev/next)
 1392:         if (document.getElementById('exercise-card-container')) {
 1393:             if (typeof window.refreshMobileWorkoutUI === 'function') {
 1394:                 window.refreshMobileWorkoutUI(preferredIndex);
 1395:             } else {
 1396:                 // Minimal fallback: update count text if present
 1397:                 const container = document.getElementById('exercise-card-container');
 1398:                 const cards = container ? container.querySelectorAll('.exercise-card') : [];
 1399:                 const currentNumSpan = document.getElementById('current-exercise-num');
 1400:                 if (currentNumSpan && cards.length > 0) {
 1401:                     // Clamp to valid range
 1402:                     const visibleIndex = Array.from(cards).findIndex(c => !c.classList.contains('d-none'));
 1403:                     currentNumSpan.textContent = String(Math.max(1, (visibleIndex >= 0 ? visibleIndex : 0) + 1));
 1404:                 }
 1405:             }
 1406:         }
 1407:     } else {
 1408:         send_toast(response.data?.detail || 'Error removing exercise', 'danger');
 1409:     }
 1410: }
 1411: 
 1412: // Refresh the mobile workout navigation UI after dynamic changes (e.g., deletion)
 1413: // Rebuilds indicators, reindexes cards, updates counter and prev/next handlers.
 1414: window.refreshMobileWorkoutUI = function(preferredIndex = null) {
 1415:     const container = document.getElementById('exercise-card-container');
 1416:     if (!container) return;
 1417: 
 1418:     container.querySelectorAll('.exercise-card').forEach(card => {
 1419:         if (!card.querySelector('.workout-exercise-card')) {
 1420:             card.remove();
 1421:         }
 1422:     });
 1423: 
 1424:     const cards = Array.from(container.querySelectorAll('.exercise-card'));
 1425:     const total = cards.length;
 1426: 
 1427:     const navBottom = document.querySelector('.exercise-navigation-bottom');
 1428:     const indicatorsContainer = document.querySelector('.exercise-indicators');
 1429:     const currentNumSpan = document.getElementById('current-exercise-num');
 1430:     const totalNumSpan = document.getElementById('total-exercises-num');
 1431: 
 1432:     if (total === 0) {
 1433:         if (navBottom) navBottom.style.display = 'none';
 1434:         if (currentNumSpan) currentNumSpan.textContent = '0';
 1435:         if (totalNumSpan) totalNumSpan.textContent = '0';
 1436:         if (window.mobileWorkoutController && typeof window.mobileWorkoutController.refresh === 'function') {
 1437:             window.mobileWorkoutController.refresh();
 1438:         }
 1439:         return;
 1440:     }
 1441: 
 1442:     cards.forEach((card, idx) => {
 1443:         card.dataset.exerciseIndex = idx;
 1444:     });
 1445: 
 1446:     if (indicatorsContainer) {
 1447:         indicatorsContainer.innerHTML = '';
 1448:         for (let i = 0; i < total; i++) {
 1449:             const dot = document.createElement('div');
 1450:             dot.className = 'indicator';
 1451:             dot.dataset.exerciseIndex = i;
 1452:             indicatorsContainer.appendChild(dot);
 1453:         }
 1454:     }
 1455: 
 1456:     if (totalNumSpan) totalNumSpan.textContent = String(total);
 1457:     if (navBottom) navBottom.style.display = '';
 1458: 
 1459:     let targetIndex = null;
 1460:     if (Number.isInteger(preferredIndex)) {
 1461:         targetIndex = preferredIndex;
 1462:     }
 1463: 
 1464:     if (window.mobileWorkoutController && typeof window.mobileWorkoutController.refresh === 'function') {
 1465:         window.mobileWorkoutController.refresh(targetIndex);
 1466:     } else {
 1467:         const clampedIndex = targetIndex !== null ? Math.max(0, Math.min(targetIndex, total - 1)) : 0;
 1468:         cards.forEach(card => card.classList.add('d-none'));
 1469:         const targetCard = cards[clampedIndex];
 1470:         if (targetCard) targetCard.classList.remove('d-none');
 1471:         if (currentNumSpan) currentNumSpan.textContent = String(clampedIndex + 1);
 1472:         const prevBtn = document.getElementById('prev-exercise');
 1473:         const nextBtn = document.getElementById('next-exercise');
 1474:         if (prevBtn) prevBtn.disabled = clampedIndex === 0;
 1475:         if (nextBtn) nextBtn.disabled = clampedIndex === total - 1;
 1476:         document.querySelectorAll('.indicator').forEach((indicator, idx) => {
 1477:             indicator.classList.toggle('active', idx === clampedIndex);
 1478:         });
 1479:     }
 1480: };
 1481: 
 1482: // --- Add Existing Exercise to Workout ---
 1483: // Triggered by data-function="click->addExerciseToWorkout"
 1484: // Needs data-workout-id="{{ workout.id }}" on the button
 1485: // Assumes select#exercise-select and select#exercise-type exist nearby
 1486: async function addExerciseToWorkout(event) {
 1487:     const button = event.target;
 1488:     const workoutId = button.dataset.workoutId;
 1489:     if (!workoutId) {
 1490:         console.error('Missing data-workout-id');
 1491:         return;
 1492:     }
 1493: 
 1494:     // Find controls - assuming they are in a shared parent/container
 1495:     const container = button.closest('.add-exercise-controls'); // Adjust selector
 1496:     if (!container) {
 1497:          console.error('Cannot find container for add exercise controls');
 1498:          return;
 1499:     }
 1500:     const exerciseSelect = container.querySelector('select[name="exercise"]'); // Use name selector instead of ID
 1501:     const typeSelect = container.querySelector('select[name="exercise_type"]');
 1502: 
 1503:     const exerciseId = exerciseSelect?.value;
 1504:     const exerciseType = typeSelect?.value;
 1505: 
 1506:     if (!exerciseId) {
 1507:         send_toast('Please select an exercise', 'warning');
 1508:         return;
 1509:     }
 1510: 
 1511:     const url = `/api/workouts/${workoutId}/add_exercise/`;
 1512:     const data = { exercise: exerciseId, exercise_type: exerciseType };
 1513: 
 1514:     const response = await httpRequestHelper(url, 'POST', data);
 1515: 
 1516:     if (response.ok) {
 1517:         send_toast('Exercise added to workout', 'success');
 1518:         window.location.reload(); // Reload to see the change
 1519:     } else {
 1520:         send_toast(response.data?.detail || 'Error adding exercise', 'danger');
 1521:     }
 1522: }
 1523: 
 1524: // ======================================
 1525: // EXERCISE LIST FILTERING & SEARCH
 1526: // ======================================
 1527: 
 1528: function debounce(func, delay) {
 1529:     let timeoutId;
 1530:     return function(...args) {
 1531:         clearTimeout(timeoutId);
 1532:         timeoutId = setTimeout(() => {
 1533:             func.apply(this, args);
 1534:         }, delay);
 1535:     };
 1536: }
 1537: 
 1538: // Make this function global for data-function
 1539: window.fetchAndUpdateExerciseList = async function() {
 1540:     const form = document.getElementById('exercise-filter-form');
 1541:     if (!form) return;
 1542: 
 1543:     const searchInput = document.getElementById('exercise-search');
 1544:     const typeFilter = document.getElementById('exercise-type-filter');
 1545:     const categoryFilter = document.getElementById('category-filter');
 1546:     const customFilter = document.getElementById('custom-filter');
 1547:     const listContainer = document.getElementById('exercise-list-container');
 1548: 
 1549:     if (!listContainer) return;
 1550: 
 1551:     const params = new URLSearchParams();
 1552:     if (searchInput && searchInput.value) { // Added null check for searchInput
 1553:         params.append('search_query', searchInput.value);
 1554:     }
 1555:     if (typeFilter && typeFilter.value) { // Added null check for typeFilter
 1556:         params.append('exercise_type', typeFilter.value);
 1557:     }
 1558:     if (categoryFilter && categoryFilter.value) { // Added null check for categoryFilter
 1559:         params.append('category', categoryFilter.value);
 1560:     }
 1561:     if (customFilter && customFilter.value) { // Added custom filter
 1562:         params.append('custom_filter', customFilter.value);
 1563:     }
 1564: 
 1565:     // Don't update the URL - just make the AJAX request
 1566:     try {
 1567:         // Use the exercises URL directly
 1568:         const url = '/exercises/?' + params.toString();
 1569:         console.log('Fetching exercises from:', url);  // Debug log
 1570: 
 1571:         const response = await fetch(url, {
 1572:             method: 'GET',
 1573:             headers: {
 1574:                 'X-Requested-With': 'XMLHttpRequest'
 1575:             },
 1576:             credentials: 'same-origin'  // Include cookies for authentication
 1577:         });
 1578: 
 1579:         console.log('Response status:', response.status);  // Debug log
 1580: 
 1581:         if (!response.ok) {
 1582:             console.error('Error fetching exercise list:', response.status, response.statusText);
 1583:             const errorText = await response.text();
 1584:             console.error('Error details:', errorText);
 1585:             listContainer.innerHTML = '<p class="text-danger">Error loading exercises. Please try again.</p>';
 1586:             return;
 1587:         }
 1588: 
 1589:         const html = await response.text();
 1590:         listContainer.innerHTML = html;
 1591: 
 1592:         // Event listeners are automatically attached via MutationObserver and data-function attributes
 1593:     } catch (error) {
 1594:         console.error('Fetch error:', error);
 1595:         listContainer.innerHTML = '<p class="text-danger">Error loading exercises. Please try again.</p>';
 1596:     }
 1597: }
 1598: 
 1599: // Make this debounced function global for data-function
 1600: window.debouncedFetchExercises = debounce(window.fetchAndUpdateExerciseList, 300);
 1601: 
 1602: // ======================================
 1603: //      ROUTINE FORM FUNCTIONS
 1604: // ======================================
 1605: 
 1606: function getNextRoutineExerciseIndex() {
 1607:     const exercisesContainer = document.getElementById('routine-exercises-container');
 1608:     if (!exercisesContainer) return 0;
 1609:     let maxIndex = -1;
 1610:     exercisesContainer.querySelectorAll('.exercise-routine-card').forEach(card => {
 1611:         const cardIndex = parseInt(card.dataset.index, 10);
 1612:         if (cardIndex > maxIndex) {
 1613:             maxIndex = cardIndex;
 1614:         }
 1615:     });
 1616:     return maxIndex + 1;
 1617: }
 1618: 
 1619: function updateRoutineExerciseOrderNumbers() {
 1620:     const exercisesContainer = document.getElementById('routine-exercises-container');
 1621:     if (!exercisesContainer) return;
 1622:     const cards = exercisesContainer.querySelectorAll('.exercise-routine-card');
 1623: 
 1624:     cards.forEach((card, idx) => {
 1625:         const newOrder = idx + 1;
 1626:         const orderSpan = card.querySelector('.exercise-order');
 1627:         if (orderSpan) orderSpan.textContent = newOrder;
 1628: 
 1629:         const orderInput = card.querySelector('.exercise-order-input');
 1630:         if (orderInput) orderInput.value = newOrder;
 1631: 
 1632:         const upButton = card.querySelector('[data-move-direction="up"]');
 1633:         const downButton = card.querySelector('[data-move-direction="down"]');
 1634:         if (upButton) upButton.disabled = idx === 0;
 1635:         if (downButton) downButton.disabled = idx === cards.length - 1;
 1636:     });
 1637: }
 1638: 
 1639: function updateRoutineFormCount() {
 1640:     const exercisesContainer = document.getElementById('routine-exercises-container');
 1641:     if (!exercisesContainer) return;
 1642:     let formCountInput = document.querySelector('input[name="routine_exercise_form_count"]');
 1643:     if (!formCountInput) {
 1644:         formCountInput = document.createElement('input');
 1645:         formCountInput.type = 'hidden';
 1646:         formCountInput.name = 'routine_exercise_form_count';
 1647:         const routineForm = document.getElementById('routineForm');
 1648:         if (routineForm) routineForm.appendChild(formCountInput);
 1649:     }
 1650:     if(formCountInput) formCountInput.value = exercisesContainer.querySelectorAll('.exercise-routine-card').length;
 1651: }
 1652: 
 1653: // window.addRoutineExerciseCard = function(event) { // This function is being replaced by the modal workflow
 1654: //     const exercisesContainer = document.getElementById('routine-exercises-container');
 1655: //     const exerciseTemplateHTML = document.getElementById('routine-exercise-template')?.innerHTML;
 1656: //     if (!exercisesContainer || !exerciseTemplateHTML) {
 1657: //         console.error('Missing exercises container or template for routine exercises.');
 1658: //         return;
 1659: //     }
 1660: //
 1661: //     const newIndex = getNextRoutineExerciseIndex();
 1662: //     const defaultOrder = exercisesContainer.querySelectorAll('.exercise-routine-card').length + 1;
 1663: //
 1664: //     const newExerciseHtml = exerciseTemplateHTML.replace(/__INDEX__/g, newIndex)
 1665: //                                               .replace(/__DEFAULT_ORDER__/g, defaultOrder);
 1666: //     const tempDiv = document.createElement('div');
 1667: //     tempDiv.innerHTML = newExerciseHtml;
 1668: //
 1669: //     const newCard = tempDiv.firstElementChild;
 1670: //     if (newCard) {
 1671: //         exercisesContainer.appendChild(newCard);
 1672: //         // Explicitly set order for the new card's input and span
 1673: //         const orderInputForNewCard = newCard.querySelector(`input[name="order_${newIndex}"]`);
 1674: //         if(orderInputForNewCard) orderInputForNewCard.value = defaultOrder;
 1675: //         const orderSpanForNewCard = newCard.querySelector('.exercise-order');
 1676: //         if(orderSpanForNewCard) orderSpanForNewCard.textContent = defaultOrder;
 1677: //     }
 1678: //     updateRoutineFormCount();
 1679: // }
 1680: 
 1681: window.removeRoutineExerciseCard = function(event) {
 1682:     const container = document.getElementById('routine-exercises-container');
 1683:     const button = event.target;
 1684:     const cardToRemove = button.closest('.exercise-routine-card');
 1685:     if (cardToRemove) {
 1686:         cardToRemove.remove();
 1687:         updateRoutineFormCount();
 1688:         updateRoutineExerciseOrderNumbers();
 1689:         if (container && !container.querySelector('.exercise-routine-card')) {
 1690:             const nav = document.getElementById('routine-exercise-mobile-nav');
 1691:             if (nav) nav.remove();
 1692:             if (container.dataset) {
 1693:                 delete container.dataset.routineMobileInit;
 1694:                 delete container.dataset.routineCurrentIndex;
 1695:             }
 1696:             const emptyMessage = document.createElement('p');
 1697:             emptyMessage.className = 'text-muted routine-empty-message';
 1698:             emptyMessage.textContent = 'No exercises added yet. Use "Add Exercise" to get started.';
 1699:             container.appendChild(emptyMessage);
 1700:         } else {
 1701:             initializeRoutineMobileView();
 1702:         }
 1703:     }
 1704: };
 1705: 
 1706: 
 1707: window.handleRoutineExerciseMove = function(event) {
 1708:     const trigger = event.target.closest('[data-move-direction]');
 1709:     if (!trigger) return;
 1710: 
 1711:     const direction = trigger.dataset.moveDirection;
 1712:     const card = trigger.closest('.exercise-routine-card');
 1713:     const container = card ? card.parentElement : null;
 1714:     if (!card || !container) return;
 1715: 
 1716:     if (direction === 'up') {
 1717:         const previous = card.previousElementSibling;
 1718:         if (previous) {
 1719:             container.insertBefore(card, previous);
 1720:         }
 1721:     } else if (direction === 'down') {
 1722:         const next = card.nextElementSibling;
 1723:         if (next) {
 1724:             container.insertBefore(next, card);
 1725:         }
 1726:     }
 1727: 
 1728:     updateRoutineExerciseOrderNumbers();
 1729:     bindRoutineSetSyncHandlers(newCard);
 1730: };
 1731: 
 1732: // --- Routine Form Modal Functions ---
 1733: window.showAddExerciseToRoutineModal = function(event) {
 1734:     const modal = document.getElementById('add-exercise-to-routine-modal');
 1735:     if (modal) {
 1736:         // Reset the select input and clear any previous error messages
 1737:         const exerciseSelect = modal.querySelector('#modal-exercise-select');
 1738:         if (exerciseSelect) {
 1739:             exerciseSelect.value = ''; // Reset to the placeholder
 1740:             exerciseSelect.classList.remove('is-invalid');
 1741:         }
 1742:         modal.style.display = 'flex';
 1743:     }
 1744: }
 1745: 
 1746: let draggedItem = null;
 1747: let floatingClone = null;
 1748: let dragOffsetX = 0;
 1749: let dragOffsetY = 0;
 1750: 
 1751: function handleDragStart(event) {
 1752:     draggedItem = event.target; // The original card
 1753:     if (!draggedItem.classList.contains('exercise-routine-card')) return; // Ensure we are dragging the correct item
 1754: 
 1755:     event.dataTransfer.effectAllowed = 'move';
 1756:     event.dataTransfer.setData('text/plain', draggedItem.dataset.index); // Still useful for context
 1757: 
 1758:     // Create a transparent 1x1 pixel image to hide the default OS ghost
 1759:     const img = new Image();
 1760:     img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
 1761:     event.dataTransfer.setDragImage(img, 0, 0);
 1762: 
 1763:     // Create a visual clone for dragging
 1764:     floatingClone = draggedItem.cloneNode(true);
 1765:     floatingClone.classList.add('dragging-clone'); // New class for styling the clone
 1766: 
 1767:     // Ensure the clone has the same dimensions as the original item
 1768:     const rect = draggedItem.getBoundingClientRect();
 1769:     floatingClone.style.width = `${rect.width}px`;
 1770:     floatingClone.style.height = `${rect.height}px`;
 1771:     // Apply all computed styles from the original to the clone to match appearance as closely as possible
 1772:     // This is more robust than just width/height but can be performance intensive if abused.
 1773:     // For now, let's stick to width/height, if more is needed we can iterate.
 1774:     /*
 1775:     const originalStyles = window.getComputedStyle(draggedItem);
 1776:     for (let i = 0; i < originalStyles.length; i++) {
 1777:         const key = originalStyles[i];
 1778:         floatingClone.style.setProperty(key, originalStyles.getPropertyValue(key), originalStyles.getPropertyPriority(key));
 1779:     }
 1780:     */
 1781: 
 1782:     document.body.appendChild(floatingClone);
 1783: 
 1784:     // Calculate mouse offset relative to the dragged item (using the new rect)
 1785:     dragOffsetX = event.clientX - rect.left;
 1786:     dragOffsetY = event.clientY - rect.top;
 1787: 
 1788:     // Position the clone initially under the mouse
 1789:     floatingClone.style.left = `${event.clientX - dragOffsetX}px`;
 1790:     floatingClone.style.top = `${event.clientY - dragOffsetY}px`;
 1791: 
 1792:     // Hide the original item (it will be moved on drop)
 1793:     setTimeout(() => { // Timeout to allow initial setup before hiding
 1794:         if(draggedItem) draggedItem.classList.add('drag-source-hidden');
 1795:     }, 0);
 1796: 
 1797:     document.addEventListener('dragover', handleDragMouseMove); // Use dragover on document for continuous position update
 1798: }
 1799: 
 1800: function handleDragMouseMove(event) {
 1801:     if (floatingClone) {
 1802:         // event.preventDefault(); // Important if this listener is on a droppable area, less so on document for just tracking mouse
 1803:         floatingClone.style.left = `${event.clientX - dragOffsetX}px`;
 1804:         floatingClone.style.top = `${event.clientY - dragOffsetY}px`;
 1805:     }
 1806: }
 1807: 
 1808: function handleDragEnd(event) {
 1809:     if (floatingClone) {
 1810:         document.body.removeChild(floatingClone);
 1811:         floatingClone = null;
 1812:     }
 1813:     if (draggedItem) {
 1814:         draggedItem.classList.remove('drag-source-hidden');
 1815:         draggedItem.style.opacity = ''; // Reset any direct opacity manipulations
 1816:     }
 1817:     draggedItem = null;
 1818:     document.removeEventListener('dragover', handleDragMouseMove);
 1819: }
 1820: 
 1821: // handleDragOver on the container needs to be adjusted
 1822: // For now, it will just allow drop and maybe show where draggedItem (original hidden one) would go
 1823: function handleDragOver(event) {
 1824:     event.preventDefault();
 1825:     event.dataTransfer.dropEffect = 'move';
 1826:     // Original reordering logic based on the hidden draggedItem might still work
 1827:     // if we consider its placeholder or conceptual position
 1828:     const container = event.currentTarget;
 1829:     if (!draggedItem) return; // If original item reference is lost
 1830: 
 1831:     const afterElement = getDragAfterElement(container, event.clientY, draggedItem);
 1832:     if (afterElement === undefined && container.lastChild !== draggedItem && !draggedItem.contains(container.lastChild)) {
 1833:         // append to end if no element to insert before, and it's not already there or a child
 1834:         // This needs to operate on a placeholder for draggedItem or the draggedItem itself if it's only hidden, not removed
 1835:     } else if (afterElement && afterElement !== draggedItem && !draggedItem.contains(afterElement)) {
 1836:         // container.insertBefore(draggedItem, afterElement);
 1837:     }
 1838:      // More complex logic will be needed here to show a placeholder for the hidden draggedItem
 1839:      // and reorder other items around this conceptual placeholder.
 1840:      // For now, let's focus on the floating clone visual.
 1841: }
 1842: 
 1843: function getDragAfterElement(container, y, currentDraggedItem) { // Added currentDraggedItem
 1844:     const draggableElements = [...container.querySelectorAll('.exercise-routine-card:not(.drag-source-hidden)')];
 1845: 
 1846:     return draggableElements.reduce((closest, child) => {
 1847:         if (child === currentDraggedItem) return closest; // Don't compare with the item being dragged
 1848:         const box = child.getBoundingClientRect();
 1849:         const offset = y - box.top - box.height / 2;
 1850:         if (offset < 0 && offset > closest.offset) {
 1851:             return { offset: offset, element: child };
 1852:         } else {
 1853:             return closest;
 1854:         }
 1855:     }, { offset: Number.NEGATIVE_INFINITY }).element;
 1856: }
 1857: 
 1858: function handleDrop(event) {
 1859:     event.preventDefault();
 1860:     if (draggedItem) {
 1861:         // Logic to place the original draggedItem into the correct spot
 1862:         // This will now use the position of the drop event, relative to other items
 1863:         const container = document.getElementById('routine-exercises-container');
 1864:         const afterElement = getDragAfterElement(container, event.clientY, draggedItem);
 1865: 
 1866:         if (afterElement) {
 1867:             container.insertBefore(draggedItem, afterElement);
 1868:         } else {
 1869:             container.appendChild(draggedItem); // Append to end if no element to insert before
 1870:         }
 1871:         draggedItem.classList.remove('drag-source-hidden'); // Make it visible
 1872:     }
 1873: 
 1874:     updateRoutineExerciseOrderNumbers();
 1875:     bindRoutineSetSyncHandlers(newCard);
 1876:     // draggedItem is reset in dragend
 1877: }
 1878: 
 1879: function setupDragAndDropListeners(cardElement) {
 1880:     if (!cardElement || cardElement.dataset.routineDragBound === 'true') {
 1881:         return;
 1882:     }
 1883:     cardElement.dataset.routineDragBound = 'true';
 1884:     cardElement.addEventListener('dragstart', handleDragStart);
 1885:     cardElement.addEventListener('dragend', handleDragEnd);
 1886:     // Add touch support for mobile (desktop drag will ignore this)
 1887:     addTouchDragSupport(cardElement, 'routine-exercises');
 1888: }
 1889: 
 1890: function isRoutineDragEnabled() {
 1891:     return !window.matchMedia('(pointer: coarse)').matches;
 1892: }
 1893: 
 1894: function prepareRoutineExerciseCard(cardElement) {
 1895:     if (!cardElement) {
 1896:         return;
 1897:     }
 1898: 
 1899:     if (isRoutineDragEnabled()) {
 1900:         cardElement.setAttribute('draggable', 'true');
 1901:         setupDragAndDropListeners(cardElement);
 1902:     } else {
 1903:         cardElement.setAttribute('draggable', 'false');
 1904:     }
 1905: 
 1906:     const { tbody } = getRoutineSetsElements(cardElement);
 1907:     if (tbody && !tbody.querySelector('.set-row')) {
 1908:         ensureRoutineSetsEmptyRow(tbody);
 1909:     }
 1910: 
 1911:     updateRoutineTypeSummary(cardElement);
 1912: }
 1913: 
 1914: const ROUTINE_SET_COLUMNS = 7;
 1915: 
 1916: function getRoutineSetsElements(exerciseCard) {
 1917:     if (!exerciseCard) {
 1918:         return { setsContainer: null, tbody: null };
 1919:     }
 1920:     const setsContainer = exerciseCard.querySelector('.sets-container');
 1921:     const tbody = setsContainer ? setsContainer.querySelector('.sets-tbody') : null;
 1922:     return { setsContainer, tbody };
 1923: }
 1924: 
 1925: function ensureRoutineSetsEmptyRow(tbody) {
 1926:     if (!tbody || tbody.querySelector('.sets-empty-message')) {
 1927:         return;
 1928:     }
 1929:     const emptyRow = document.createElement('tr');
 1930:     emptyRow.className = 'sets-empty-message';
 1931:     const cell = document.createElement('td');
 1932:     cell.colSpan = ROUTINE_SET_COLUMNS;
 1933:     cell.className = 'text-center text-muted py-3';
 1934:     cell.textContent = 'No sets planned yet.';
 1935:     emptyRow.appendChild(cell);
 1936:     tbody.appendChild(emptyRow);
 1937: }
 1938: 
 1939: function updateRoutineTypeSummary(exerciseCard, fallbackTypeDisplay) {
 1940:     if (!exerciseCard) {
 1941:         return;
 1942:     }
 1943:     const summary = exerciseCard.querySelector('.routine-type-summary');
 1944:     if (!summary) {
 1945:         return;
 1946:     }
 1947: 
 1948:     const typeSelect = exerciseCard.querySelector('.routine-type-select');
 1949:     if (typeSelect && typeSelect.value) {
 1950:         const selectedOption = typeSelect.options[typeSelect.selectedIndex];
 1951:         summary.textContent = selectedOption ? selectedOption.textContent : 'Custom type';
 1952:         return;
 1953:     }
 1954: 
 1955:     const exerciseSelect = exerciseCard.querySelector('.exercise-select');
 1956:     const selectedExerciseOption = exerciseSelect ? exerciseSelect.options[exerciseSelect.selectedIndex] : null;
 1957:     const defaultDisplay = fallbackTypeDisplay
 1958:         || (selectedExerciseOption ? selectedExerciseOption.dataset.defaultTypeDisplay : null)
 1959:         || 'Select Exercise First';
 1960: 
 1961:     summary.textContent = `Default (${defaultDisplay})`;
 1962: }
 1963: 
 1964: function updateRoutineSpecificTypeLabel(event) {
 1965:     if (event) {
 1966:         event.preventDefault?.();
 1967:     }
 1968:     const select = event?.target || null;
 1969:     const exerciseCard = select ? select.closest('.exercise-routine-card') : null;
 1970:     if (!exerciseCard) {
 1971:         return;
 1972:     }
 1973:     updateRoutineTypeSummary(exerciseCard);
 1974: }
 1975: 
 1976: function updateExerciseCardName(event) {
 1977:     if (!event || !event.target) {
 1978:         return;
 1979:     }
 1980:     const selectElement = event.target;
 1981:     const exerciseCard = selectElement.closest('.exercise-routine-card');
 1982:     if (!exerciseCard) {
 1983:         return;
 1984:     }
 1985: 
 1986:     const selectedOption = selectElement.options[selectElement.selectedIndex];
 1987:     const exerciseName = selectedOption?.dataset.name || selectedOption?.text || 'Select Exercise';
 1988:     const defaultTypeDisplay = selectedOption?.dataset.defaultTypeDisplay || 'Select Exercise First';
 1989: 
 1990:     const nameDisplay = exerciseCard.querySelector('.exercise-name-display');
 1991:     if (nameDisplay) {
 1992:         nameDisplay.textContent = exerciseName;
 1993:     }
 1994: 
 1995:     const routineTypeSelect = exerciseCard.querySelector('.routine-type-select');
 1996:     if (routineTypeSelect && routineTypeSelect.options.length > 0) {
 1997:         const defaultOption = routineTypeSelect.options[0];
 1998:         defaultOption.textContent = `Default (${defaultTypeDisplay})`;
 1999:         if (!routineTypeSelect.value) {
 2000:             updateRoutineTypeSummary(exerciseCard, defaultTypeDisplay);
 2001:         }
 2002:     } else {
 2003:         updateRoutineTypeSummary(exerciseCard, defaultTypeDisplay);
 2004:     }
 2005: }
 2006: 
 2007: function appendExerciseCardToRoutine(exerciseId, exerciseName, defaultTypeDisplay, routineSpecificType) {
 2008:     const template = document.getElementById('routine-exercise-template');
 2009:     if (!template) {
 2010:         console.error('#routine-exercise-template not found!');
 2011:         return null;
 2012:     }
 2013: 
 2014:     const container = document.getElementById('routine-exercises-container');
 2015:     if (!container) {
 2016:         console.error('#routine-exercises-container not found!');
 2017:         return null;
 2018:     }
 2019: 
 2020:     const nextIndex = getNextRoutineExerciseIndex();
 2021:     const defaultOrder = container.querySelectorAll('.exercise-routine-card').length + 1;
 2022:     const fallbackType = defaultTypeDisplay || 'Select Exercise First';
 2023: 
 2024:     let content = template.innerHTML;
 2025:     content = content.replace(/__INDEX__/g, nextIndex)
 2026:                      .replace(/__ORDER__/g, defaultOrder)
 2027:                      .replace(/__EXERCISE_NAME__/g, exerciseName || 'Select Exercise')
 2028:                      .replace(/__DEFAULT_TYPE__/g, fallbackType);
 2029: 
 2030:     const tempDiv = document.createElement('div');
 2031:     tempDiv.innerHTML = content;
 2032:     const newCard = tempDiv.firstElementChild;
 2033:     if (!newCard) {
 2034:         console.error('Could not create new exercise card from template content.');
 2035:         return null;
 2036:     }
 2037: 
 2038:     newCard.dataset.index = String(nextIndex);
 2039: 
 2040:     const orderInput = newCard.querySelector('.exercise-order-input');
 2041:     if (orderInput) {
 2042:         orderInput.value = defaultOrder;
 2043:     }
 2044: 
 2045:     const emptyMessage = container.querySelector('.routine-empty-message');
 2046:     if (emptyMessage) {
 2047:         emptyMessage.remove();
 2048:     }
 2049: 
 2050:     const exerciseSelect = newCard.querySelector('.exercise-select');
 2051:     if (exerciseSelect && exerciseId) {
 2052:         exerciseSelect.value = exerciseId;
 2053:         updateExerciseCardName({ target: exerciseSelect });
 2054:     } else {
 2055:         updateRoutineTypeSummary(newCard, fallbackType);
 2056:     }
 2057: 
 2058:     const routineTypeSelect = newCard.querySelector('.routine-type-select');
 2059:     if (routineTypeSelect && routineSpecificType) {
 2060:         routineTypeSelect.value = routineSpecificType;
 2061:         updateRoutineTypeSummary(newCard);
 2062:     }
 2063: 
 2064:     container.appendChild(newCard);
 2065:     prepareRoutineExerciseCard(newCard);
 2066:     addSetToExerciseCard(newCard);
 2067:     updateRoutineExerciseOrderNumbers();
 2068:     updateRoutineFormCount();
 2069:     updateSetRowFieldVisibility();
 2070:     bindRoutineSetSyncHandlers(newCard);`n    initializeRoutineMobileView();
 2071: 
 2072:     return newCard;
 2073: }
 2074: 
 2075: function addSetToExerciseCard(eventOrCardElement) {
 2076:     let exerciseCard = null;
 2077:     if (eventOrCardElement instanceof HTMLElement && eventOrCardElement.classList.contains('exercise-routine-card')) {
 2078:         exerciseCard = eventOrCardElement;
 2079:     } else if (eventOrCardElement?.target) {
 2080:         eventOrCardElement.preventDefault?.();
 2081:         exerciseCard = eventOrCardElement.target.closest('.exercise-routine-card');
 2082:     }
 2083: 
 2084:     if (!exerciseCard) {
 2085:         return null;
 2086:     }
 2087: 
 2088:     const { tbody } = getRoutineSetsElements(exerciseCard);
 2089:     if (!tbody) {
 2090:         return null;
 2091:     }
 2092: 
 2093:     const emptyRow = tbody.querySelector('.sets-empty-message');
 2094:     if (emptyRow) {
 2095:         emptyRow.remove();
 2096:     }
 2097: 
 2098:     const existingRows = Array.from(tbody.querySelectorAll('.set-row'));
 2099:     let newRow;
 2100: 
 2101:     if (existingRows.length > 0) {
 2102:         const sourceRow = existingRows[existingRows.length - 1];
 2103:         newRow = sourceRow.cloneNode(true);
 2104:         newRow.dataset.setIndex = existingRows.length;
 2105: 
 2106:         newRow.querySelectorAll('input, select, textarea').forEach(input => {
 2107:             if (!input.name) {
 2108:                 return;
 2109:             }
 2110:             if (input.type === 'hidden' && input.name.endsWith('_id')) {
 2111:                 input.value = '';
 2112:             } else if (input.classList.contains('set-number-input')) {
 2113:                 input.value = existingRows.length + 1;
 2114:             }
 2115:             if (input.dataset) {
 2116:                 input.dataset.originalValue = input.value ?? '';
 2117:             }
 2118:         });
 2119:     } else {
 2120:         const setTemplate = document.getElementById('set-row-template');
 2121:         if (!setTemplate) {
 2122:             console.error('#set-row-template not found!');
 2123:             return null;
 2124:         }
 2125: 
 2126:         const fragment = setTemplate.content.cloneNode(true);
 2127:         newRow = fragment.querySelector('.set-row');
 2128:         newRow.dataset.setIndex = 0;
 2129: 
 2130:         newRow.querySelectorAll('input, select, textarea').forEach(input => {
 2131:             if (!input.name) {
 2132:                 return;
 2133:             }
 2134:             input.name = input.name
 2135:                 .replace(/__EXERCISE_INDEX__/g, exerciseCard.dataset.index)
 2136:                 .replace(/__SET_INDEX__/g, 0)
 2137:                 .replace(/__SET_NUMBER__/g, 1);
 2138: 
 2139:             if (input.type === 'hidden' && input.name.endsWith('_id')) {
 2140:                 input.value = '';
 2141:             } else if (input.classList.contains('set-number-input')) {
 2142:                 input.value = 1;
 2143:             } else {
 2144:                 input.value = '';
 2145:             }
 2146:             if (input.dataset) {
 2147:                 input.dataset.originalValue = input.value ?? '';
 2148:             }
 2149:         });
 2150:     }
 2151: 
 2152:     tbody.appendChild(newRow);
 2153:     updateSetNumbers(exerciseCard);
 2154:     updateSetRowFieldVisibility();
 2155:     bindRoutineSetSyncHandlers(exerciseCard);`n    return newRow;
 2156: }
 2157: function removeSetFromExerciseCard(event) {
 2158:     if (event) {
 2159:         event.preventDefault?.();
 2160:     }
 2161:     const trigger = event?.target;
 2162:     const setRow = trigger ? trigger.closest('.set-row') : null;
 2163:     if (!setRow) {
 2164:         return;
 2165:     }
 2166: 
 2167:     const exerciseCard = setRow.closest('.exercise-routine-card');
 2168:     const { tbody } = getRoutineSetsElements(exerciseCard);
 2169:     setRow.remove();
 2170: 
 2171:     updateSetNumbers(exerciseCard);
 2172:     if (tbody && !tbody.querySelector('.set-row')) {
 2173:         ensureRoutineSetsEmptyRow(tbody);
 2174:     }
 2175: }
 2176: 
 2177: function duplicateSetRow(event) {
 2178:     if (event) {
 2179:         event.preventDefault?.();
 2180:     }
 2181:     const trigger = event?.target;
 2182:     const sourceRow = trigger ? trigger.closest('.set-row') : null;
 2183:     if (!sourceRow) {
 2184:         return;
 2185:     }
 2186: 
 2187:     const exerciseCard = sourceRow.closest('.exercise-routine-card');
 2188:     const { tbody } = getRoutineSetsElements(exerciseCard);
 2189:     if (!tbody) {
 2190:         return;
 2191:     }
 2192: 
 2193:     const emptyRow = tbody.querySelector('.sets-empty-message');
 2194:     if (emptyRow) {
 2195:         emptyRow.remove();
 2196:     }
 2197: 
 2198:     const clone = sourceRow.cloneNode(true);
 2199:     clone.querySelectorAll('input, select, textarea').forEach(input => {
 2200:         if (input.type === 'hidden' && input.name && input.name.endsWith('_id')) {
 2201:             input.value = '';
 2202:         }
 2203:     });
 2204: 
 2205:     tbody.appendChild(clone);
 2206:     updateSetNumbers(exerciseCard);
 2207:     updateSetRowFieldVisibility();
 2208:     bindRoutineSetSyncHandlers(container);
 2209: }
 2210: function getRoutineSetFieldKey(input) {
 2211:     const name = input?.name || '';
 2212:     if (name.includes('_target_reps')) {
 2213:         return 'target_reps';
 2214:     }
 2215:     if (name.includes('_target_weight')) {
 2216:         return 'target_weight';
 2217:     }
 2218:     return null;
 2219: }
 2220: 
 2221: function normalizeRoutineSetFieldValue(value, fieldKey) {
 2222:     if (value === null || value === undefined) {
 2223:         return '';
 2224:     }
 2225:     const trimmed = String(value).trim();
 2226:     if (!trimmed) {
 2227:         return '';
 2228:     }
 2229:     if (fieldKey === 'target_weight') {
 2230:         const numeric = Number(trimmed);
 2231:         return Number.isFinite(numeric) ? numeric : trimmed;
 2232:     }
 2233:     return trimmed;
 2234: }
 2235: 
 2236: function captureRoutineSetFieldOriginalValue(event) {
 2237:     const input = event?.target;
 2238:     if (!input) {
 2239:         return;
 2240:     }
 2241:     input.dataset.originalValue = input.value ?? '';
 2242: }
 2243: 
 2244: function handleRoutineSetFieldChange(event) {
 2245:     const input = event?.target;
 2246:     if (!input) {
 2247:         return;
 2248:     }
 2249: 
 2250:     const fieldKey = getRoutineSetFieldKey(input);
 2251:     const newValue = input.value ?? '';
 2252:     const originalValue = input.dataset.originalValue ?? '';
 2253:     input.dataset.originalValue = newValue;
 2254: 
 2255:     if (!fieldKey) {
 2256:         return;
 2257:     }
 2258: 
 2259:     const normalizedOriginal = normalizeRoutineSetFieldValue(originalValue, fieldKey);
 2260:     const normalizedNew = normalizeRoutineSetFieldValue(newValue, fieldKey);
 2261:     if (normalizedOriginal === normalizedNew) {
 2262:         return;
 2263:     }
 2264: 
 2265:     const exerciseCard = input.closest('.exercise-routine-card');
 2266:     if (!exerciseCard) {
 2267:         return;
 2268:     }
 2269: 
 2270:     const selector = `input[name*="_${fieldKey}"]`;
 2271: 
 2272:     exerciseCard.querySelectorAll(selector).forEach(otherInput => {
 2273:         if (otherInput === input) {
 2274:             return;
 2275:         }
 2276:         const otherValue = otherInput.value ?? '';
 2277:         if (normalizeRoutineSetFieldValue(otherValue, fieldKey) !== normalizedOriginal) {
 2278:             return;
 2279:         }
 2280:         otherInput.value = newValue;
 2281:         otherInput.dataset.originalValue = newValue;
 2282:     });
 2283: }
 2284: 
 2285: function updateSetNumbers(exerciseCard) {
 2286:     if (!exerciseCard) {
 2287:         return;
 2288:     }
 2289:     const exerciseIndex = exerciseCard.dataset.index;
 2290:     const { tbody } = getRoutineSetsElements(exerciseCard);
 2291:     if (!tbody) {
 2292:         return;
 2293:     }
 2294: 
 2295:     const rows = Array.from(tbody.querySelectorAll('.set-row'));
 2296:     rows.forEach((row, index) => {
 2297:         row.dataset.setIndex = index;
 2298: 
 2299:         const numberDisplay = row.querySelector('.set-number-display');
 2300:         if (numberDisplay) {
 2301:             numberDisplay.textContent = `Set ${index + 1}`;
 2302:         }
 2303: 
 2304:         row.querySelectorAll('input, select, textarea').forEach(input => {
 2305:             if (!input.name) {
 2306:                 return;
 2307:             }
 2308:             let name = input.name;
 2309:             name = name.replace(/planned_sets_\d+_/g, `planned_sets_${index}_`)
 2310:                        .replace(/planned_sets\[\d+\]/g, `planned_sets[${index}]`)
 2311:                        .replace(/__SET_INDEX__/g, index)
 2312:                        .replace(/__SET_NUMBER__/g, index + 1);
 2313:             if (exerciseIndex !== undefined && exerciseIndex !== null && exerciseIndex !== "") {
 2314:                 name = name.replace(/routine_exercise_\d+_/g, `routine_exercise_${exerciseIndex}_`)
 2315:                            .replace(/routine_exercise\[\d+\]/g, `routine_exercise[${exerciseIndex}]`)
 2316:                            .replace(/__EXERCISE_INDEX__/g, exerciseIndex);
 2317:             }
 2318:             input.name = name;
 2319: 
 2320:             if (input.classList.contains('set-number-input')) {
 2321:                 input.value = index + 1;
 2322:             }
 2323:         });
 2324:     });
 2325: 
 2326:     if (!rows.length) {
 2327:         ensureRoutineSetsEmptyRow(tbody);
 2328:     }
 2329: }
 2330: 
 2331: function updateSetRowFieldVisibility() {
 2332:     const showRPE = document.getElementById('toggle-rpe-visibility')?.checked ?? true;
 2333:     const showRest = document.getElementById('toggle-rest-time-visibility')?.checked ?? true;
 2334:     const showNotes = document.getElementById('toggle-notes-visibility')?.checked ?? true;
 2335: 
 2336:     document.querySelectorAll('#routine-exercises-container .set-row').forEach(row => {
 2337:         const rpeField = row.querySelector('.rpe-field');
 2338:         if (rpeField) {
 2339:             rpeField.style.display = showRPE ? 'block' : 'none';
 2340:         }
 2341:         const restField = row.querySelector('.rest-time-field');
 2342:         if (restField) {
 2343:             restField.style.display = showRest ? 'block' : 'none';
 2344:         }
 2345:         const notesField = row.querySelector('.notes-field');
 2346:         if (notesField) {
 2347:             notesField.style.display = showNotes ? 'block' : 'none';
 2348:         }
 2349:     });
 2350: }
 2351: 
 2352: function addExerciseToRoutineFromForm(event) {
 2353:     if (event) {
 2354:         event.preventDefault?.();
 2355:     }
 2356: 
 2357:     const exerciseSelect = document.getElementById('routine-add-exercise-select');
 2358:     const typeSelect = document.getElementById('routine-add-exercise-type');
 2359: 
 2360:     if (!exerciseSelect) {
 2361:         return;
 2362:     }
 2363: 
 2364:     const exerciseId = exerciseSelect.value;
 2365:     if (!exerciseId) {
 2366:         if (typeof send_toast === 'function') {
 2367:             send_toast('Please select an exercise', 'warning');
 2368:         }
 2369:         return;
 2370:     }
 2371: 
 2372:     const selectedOption = exerciseSelect.options[exerciseSelect.selectedIndex];
 2373:     const exerciseName = selectedOption?.dataset.name || selectedOption?.text || 'Select Exercise';
 2374:     const defaultTypeDisplay = selectedOption?.dataset.defaultTypeDisplay || 'Select Exercise First';
 2375:     const routineSpecificType = typeSelect ? typeSelect.value : '';
 2376: 
 2377:     const newCard = appendExerciseCardToRoutine(exerciseId, exerciseName, defaultTypeDisplay, routineSpecificType);
 2378:     if (newCard && typeof send_toast === 'function') {
 2379:         send_toast('Exercise added to routine', 'success');
 2380:     }
 2381: 
 2382:     if (exerciseSelect) {
 2383:         exerciseSelect.value = '';
 2384:     }
 2385:     if (typeSelect) {
 2386:         typeSelect.value = '';
 2387:     }
 2388: }
 2389: 
 2390: function initializeRoutineForm() {
 2391:     const container = document.getElementById('routine-exercises-container');
 2392:     if (!container) {
 2393:         return;
 2394:     }
 2395: 
 2396:     container.querySelectorAll('.exercise-routine-card').forEach(card => {
 2397:         prepareRoutineExerciseCard(card);
 2398:         updateRoutineTypeSummary(card);
 2399:     });
 2400: 
 2401:     if (!container.dataset.routineListenersBound) {
 2402:         container.addEventListener('dragover', handleDragOver);
 2403:         container.addEventListener('drop', handleDrop);
 2404:         container.dataset.routineListenersBound = 'true';
 2405:     }
 2406: 
 2407:     updateRoutineExerciseOrderNumbers();
 2408:     updateRoutineFormCount();
 2409:     updateSetRowFieldVisibility();
 2410:     bindRoutineSetSyncHandlers(newCard);`n    initializeRoutineMobileView();
 2411: }
 2412: 
 2413: window.updateRoutineSpecificTypeLabel = updateRoutineSpecificTypeLabel;
 2414: window.captureRoutineSetFieldOriginalValue = captureRoutineSetFieldOriginalValue;
 2415: window.handleRoutineSetFieldChange = handleRoutineSetFieldChange;
 2416: window.captureWorkoutSetOriginalValue = captureWorkoutSetOriginalValue;
 2417: window.handleWorkoutSetChange = handleWorkoutSetChange;
 2418: window.updateExerciseCardName = updateExerciseCardName;
 2419: window.appendExerciseCardToRoutine = appendExerciseCardToRoutine;
 2420: window.addSetToExerciseCard = addSetToExerciseCard;
 2421: window.removeSetFromExerciseCard = removeSetFromExerciseCard;
 2422: window.duplicateSetRow = duplicateSetRow;
 2423: window.updateSetRowFieldVisibility = updateSetRowFieldVisibility;
 2424: window.addExerciseToRoutineFromForm = addExerciseToRoutineFromForm;
 2425: 
 2426: // ======================================
 2427: //      WORKOUT EXERCISES DRAG & DROP
 2428: // ======================================
 2429: 
 2430: let workoutDraggedItem = null;
 2431: let workoutFloatingClone = null;
 2432: let workoutDragOffsetX = 0;
 2433: let workoutDragOffsetY = 0;
 2434: 
 2435: function handleWorkoutExerciseDragStart(event) {
 2436:     workoutDraggedItem = event.target;
 2437:     if (!workoutDraggedItem.classList.contains('workout-exercise-card')) return;
 2438: 
 2439:     event.dataTransfer.effectAllowed = 'move';
 2440:     event.dataTransfer.setData('text/plain', workoutDraggedItem.dataset.exerciseId);
 2441: 
 2442:     // Create transparent image to hide default ghost
 2443:     const img = new Image();
 2444:     img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
 2445:     event.dataTransfer.setDragImage(img, 0, 0);
 2446: 
 2447:     // Create visual clone
 2448:     workoutFloatingClone = workoutDraggedItem.cloneNode(true);
 2449:     workoutFloatingClone.classList.add('dragging-clone');
 2450: 
 2451:     const rect = workoutDraggedItem.getBoundingClientRect();
 2452:     workoutFloatingClone.style.width = `${rect.width}px`;
 2453:     workoutFloatingClone.style.height = `${rect.height}px`;
 2454: 
 2455:     document.body.appendChild(workoutFloatingClone);
 2456: 
 2457:     workoutDragOffsetX = event.clientX - rect.left;
 2458:     workoutDragOffsetY = event.clientY - rect.top;
 2459: 
 2460:     workoutFloatingClone.style.left = `${event.clientX - workoutDragOffsetX}px`;
 2461:     workoutFloatingClone.style.top = `${event.clientY - workoutDragOffsetY}px`;
 2462: 
 2463:     setTimeout(() => {
 2464:         if(workoutDraggedItem) workoutDraggedItem.classList.add('drag-source-hidden');
 2465:     }, 0);
 2466: 
 2467:     document.addEventListener('dragover', handleWorkoutExerciseDragMouseMove);
 2468: }
 2469: 
 2470: function handleWorkoutExerciseDragMouseMove(event) {
 2471:     if (workoutFloatingClone) {
 2472:         workoutFloatingClone.style.left = `${event.clientX - workoutDragOffsetX}px`;
 2473:         workoutFloatingClone.style.top = `${event.clientY - workoutDragOffsetY}px`;
 2474:     }
 2475: }
 2476: 
 2477: function handleWorkoutExerciseDragEnd(event) {
 2478:     if (workoutFloatingClone) {
 2479:         document.body.removeChild(workoutFloatingClone);
 2480:         workoutFloatingClone = null;
 2481:     }
 2482:     if (workoutDraggedItem) {
 2483:         workoutDraggedItem.classList.remove('drag-source-hidden');
 2484:         workoutDraggedItem.style.opacity = '';
 2485:     }
 2486:     workoutDraggedItem = null;
 2487:     document.removeEventListener('dragover', handleWorkoutExerciseDragMouseMove);
 2488: }
 2489: 
 2490: function handleWorkoutExerciseDragOver(event) {
 2491:     event.preventDefault();
 2492:     event.dataTransfer.dropEffect = 'move';
 2493: 
 2494:     const container = event.currentTarget;
 2495:     if (!workoutDraggedItem) return;
 2496: 
 2497:     const afterElement = getWorkoutDragAfterElement(container, event.clientY, workoutDraggedItem);
 2498:     if (afterElement === undefined && container.lastChild !== workoutDraggedItem) {
 2499:         // Can move to end
 2500:     } else if (afterElement && afterElement !== workoutDraggedItem) {
 2501:         // Can insert before afterElement
 2502:     }
 2503: }
 2504: 
 2505: function getWorkoutDragAfterElement(container, y, currentDraggedItem) {
 2506:     const draggableElements = [...container.querySelectorAll('.workout-exercise-card:not(.drag-source-hidden)')];
 2507: 
 2508:     return draggableElements.reduce((closest, child) => {
 2509:         if (child === currentDraggedItem) return closest;
 2510:         const box = child.getBoundingClientRect();
 2511:         const offset = y - box.top - box.height / 2;
 2512:         if (offset < 0 && offset > closest.offset) {
 2513:             return { offset: offset, element: child };
 2514:         } else {
 2515:             return closest;
 2516:         }
 2517:     }, { offset: Number.NEGATIVE_INFINITY }).element;
 2518: }
 2519: 
 2520: function handleWorkoutExerciseDrop(event) {
 2521:     event.preventDefault();
 2522:     if (workoutDraggedItem) {
 2523:         const container = event.currentTarget;
 2524:         const afterElement = getWorkoutDragAfterElement(container, event.clientY, workoutDraggedItem);
 2525: 
 2526:         if (afterElement) {
 2527:             container.insertBefore(workoutDraggedItem, afterElement);
 2528:         } else {
 2529:             container.appendChild(workoutDraggedItem);
 2530:         }
 2531:         workoutDraggedItem.classList.remove('drag-source-hidden');
 2532: 
 2533:         // Update order in database
 2534:         updateWorkoutExerciseOrder(container);
 2535:     }
 2536: }
 2537: 
 2538: async function updateWorkoutExerciseOrder(container) {
 2539:     const workoutId = document.getElementById('workout-exercises-container').dataset.workoutId;
 2540:     const exercises = container.querySelectorAll('.workout-exercise-card');
 2541:     const updates = [];
 2542: 
 2543:     exercises.forEach((card, index) => {
 2544:         const exerciseId = card.dataset.exerciseId;
 2545:         updates.push({
 2546:             id: exerciseId,
 2547:             order: index + 1
 2548:         });
 2549:     });
 2550: 
 2551:     // Send update to backend
 2552:     try {
 2553:         const response = await httpRequestHelper(`/api/workouts/${workoutId}/reorder-exercises/`, 'POST', {
 2554:             exercises: updates
 2555:         });
 2556: 
 2557:         if (response.ok) {
 2558:             send_toast('Exercise order updated', 'success');
 2559:         } else {
 2560:             send_toast('Failed to update exercise order', 'danger');
 2561:             // Optionally reload to restore original order
 2562:         }
 2563:     } catch (error) {
 2564:         console.error('Error updating exercise order:', error);
 2565:         send_toast('Error updating exercise order', 'danger');
 2566:     }
 2567: }
 2568: 
 2569: function initializeWorkoutExercisesDragDrop() {
 2570:     bindWorkoutSetSyncHandlers(document);
 2571:     const container = document.getElementById('workout-exercises-container');
 2572:     if (!container) return;
 2573: 
 2574:     // Set up drag and drop for all exercise cards
 2575:     container.querySelectorAll('.workout-exercise-card').forEach(card => {
 2576:         card.addEventListener('dragstart', handleWorkoutExerciseDragStart);
 2577:         card.addEventListener('dragend', handleWorkoutExerciseDragEnd);
 2578:         // Add touch support for mobile
 2579:         addTouchDragSupport(card, 'workout-exercises');
 2580:     });
 2581: 
 2582:     // Set up drop zones for each category
 2583:     container.querySelectorAll('.exercise-category-container').forEach(categoryContainer => {
 2584:         categoryContainer.addEventListener('dragover', handleWorkoutExerciseDragOver);
 2585:         categoryContainer.addEventListener('drop', handleWorkoutExerciseDrop);
 2586:     });
 2587: }
 2588: 
 2589: // ======================================
 2590: //      PROGRAM ROUTINES DRAG & DROP
 2591: // ======================================
 2592: 
 2593: let programDraggedChip = null;
 2594: let programFloatingClone = null;
 2595: 
 2596: const DOUBLE_ACTIVATE_MAX_DELAY = 350;
 2597: const DOUBLE_ACTIVATE_MAX_DISTANCE = 12;
 2598: const ROUTINE_ACTIVATION_HINT = 'Double tap or double click to open routine';
 2599: const doubleActivateState = {
 2600:     lastTapTime: 0,
 2601:     lastTapX: 0,
 2602:     lastTapY: 0,
 2603:     lastTarget: null,
 2604:     resetTimer: null,
 2605: };
 2606: 
 2607: function resetDoubleActivateState() {
 2608:     if (doubleActivateState.resetTimer) {
 2609:         clearTimeout(doubleActivateState.resetTimer);
 2610:         doubleActivateState.resetTimer = null;
 2611:     }
 2612:     doubleActivateState.lastTapTime = 0;
 2613:     doubleActivateState.lastTarget = null;
 2614:     doubleActivateState.lastTapX = 0;
 2615:     doubleActivateState.lastTapY = 0;
 2616: }
 2617: 
 2618: function attachDoubleActivate(element, callback, options = {}) {
 2619:     if (!element || element.dataset.doubleActivateBound === 'true') {
 2620:         return;
 2621:     }
 2622: 
 2623:     element.dataset.doubleActivateBound = 'true';
 2624: 
 2625:     const isDragging = typeof options.isDragging === 'function' ? options.isDragging : () => false;
 2626:     const shouldIgnore = typeof options.shouldIgnore === 'function' ? options.shouldIgnore : () => false;
 2627:     const forceTabIndex = options.forceTabIndex !== false;
 2628: 
 2629:     if (forceTabIndex && element.tabIndex < 0) {
 2630:         element.tabIndex = 0;
 2631:     }
 2632: 
 2633:     element.addEventListener('dblclick', (event) => {
 2634:         if (isDragging() || shouldIgnore(event)) {
 2635:             resetDoubleActivateState();
 2636:             return;
 2637:         }
 2638:         resetDoubleActivateState();
 2639:         callback({ trigger: 'dblclick', event });
 2640:     });
 2641: 
 2642:     element.addEventListener('touchend', (event) => {
 2643:         if (isDragging() || shouldIgnore(event) || (event.touches && event.touches.length)) {
 2644:             resetDoubleActivateState();
 2645:             return;
 2646:         }
 2647: 
 2648:         const touch = event.changedTouches && event.changedTouches[0];
 2649:         if (!touch) {
 2650:             return;
 2651:         }
 2652: 
 2653:         const now = performance.now();
 2654:         const { lastTapTime, lastTapX, lastTapY, lastTarget, resetTimer } = doubleActivateState;
 2655: 
 2656:         if (resetTimer) {
 2657:             clearTimeout(resetTimer);
 2658:             doubleActivateState.resetTimer = null;
 2659:         }
 2660: 
 2661:         const isSameTarget = lastTarget === element;
 2662:         const withinTime = now - lastTapTime <= DOUBLE_ACTIVATE_MAX_DELAY;
 2663:         const withinDistance = Math.abs(touch.clientX - lastTapX) <= DOUBLE_ACTIVATE_MAX_DISTANCE &&
 2664:                                Math.abs(touch.clientY - lastTapY) <= DOUBLE_ACTIVATE_MAX_DISTANCE;
 2665: 
 2666:         if (isSameTarget && withinTime && withinDistance) {
 2667:             resetDoubleActivateState();
 2668:             event.preventDefault();
 2669:             callback({ trigger: 'doubletap', event });
 2670:             return;
 2671:         }
 2672: 
 2673:         doubleActivateState.lastTapTime = now;
 2674:         doubleActivateState.lastTapX = touch.clientX;
 2675:         doubleActivateState.lastTapY = touch.clientY;
 2676:         doubleActivateState.lastTarget = element;
 2677:         doubleActivateState.resetTimer = setTimeout(() => {
 2678:             resetDoubleActivateState();
 2679:         }, DOUBLE_ACTIVATE_MAX_DELAY);
 2680:     }, { passive: false });
 2681: 
 2682:     element.addEventListener('keydown', (event) => {
 2683:         if (isDragging() || shouldIgnore(event)) {
 2684:             return;
 2685:         }
 2686: 
 2687:         if (event.key === 'Enter' || event.key === ' ') {
 2688:             event.preventDefault();
 2689:             resetDoubleActivateState();
 2690:             callback({ trigger: 'keyboard', event });
 2691:         }
 2692:     });
 2693: }
 2694: 
 2695: function openRoutineDetail(routineId) {
 2696:     if (!routineId) {
 2697:         return;
 2698:     }
 2699: 
 2700:     const url = `/routines/${routineId}/`;
 2701:     const newWindow = window.open(url, '_blank');
 2702:     if (newWindow) {
 2703:         newWindow.opener = null;
 2704:     } else {
 2705:         window.location.assign(url);
 2706:     }
 2707: }
 2708: 
 2709: let programDragOffsetX = 0;
 2710: let programDragOffsetY = 0;
 2711: 
 2712: function handleProgramRoutineDragStart(event) {
 2713:     programDraggedChip = event.target;
 2714:     if (!programDraggedChip.classList.contains('routine-chip')) return;
 2715: 
 2716:     event.dataTransfer.effectAllowed = 'move';
 2717:     event.dataTransfer.setData('text/plain', programDraggedChip.dataset.routineId);
 2718: 
 2719:     // Create transparent image to hide default ghost
 2720:     const img = new Image();
 2721:     img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
 2722:     event.dataTransfer.setDragImage(img, 0, 0);
 2723: 
 2724:     // Create visual clone
 2725:     programFloatingClone = programDraggedChip.cloneNode(true);
 2726:     programFloatingClone.classList.add('dragging-clone');
 2727: 
 2728:     const rect = programDraggedChip.getBoundingClientRect();
 2729:     programFloatingClone.style.width = `${rect.width}px`;
 2730:     programFloatingClone.style.height = `${rect.height}px`;
 2731: 
 2732:     document.body.appendChild(programFloatingClone);
 2733: 
 2734:     programDragOffsetX = event.clientX - rect.left;
 2735:     programDragOffsetY = event.clientY - rect.top;
 2736: 
 2737:     programFloatingClone.style.left = `${event.clientX - programDragOffsetX}px`;
 2738:     programFloatingClone.style.top = `${event.clientY - programDragOffsetY}px`;
 2739: 
 2740:     setTimeout(() => {
 2741:         if(programDraggedChip) programDraggedChip.classList.add('drag-source-hidden');
 2742:     }, 0);
 2743: 
 2744:     document.addEventListener('dragover', handleProgramRoutineDragMouseMove);
 2745: }
 2746: 
 2747: function handleProgramRoutineDragMouseMove(event) {
 2748:     if (programFloatingClone) {
 2749:         programFloatingClone.style.left = `${event.clientX - programDragOffsetX}px`;
 2750:         programFloatingClone.style.top = `${event.clientY - programDragOffsetY}px`;
 2751:     }
 2752: }
 2753: 
 2754: function handleProgramRoutineDragEnd(event) {
 2755:     if (programFloatingClone) {
 2756:         document.body.removeChild(programFloatingClone);
 2757:         programFloatingClone = null;
 2758:     }
 2759:     if (programDraggedChip) {
 2760:         programDraggedChip.classList.remove('drag-source-hidden');
 2761:         programDraggedChip.style.opacity = '';
 2762:     }
 2763:     programDraggedChip = null;
 2764:     document.removeEventListener('dragover', handleProgramRoutineDragMouseMove);
 2765: }
 2766: 
 2767: function handleProgramRoutineDragOver(event) {
 2768:     event.preventDefault();
 2769:     event.dataTransfer.dropEffect = 'move';
 2770: 
 2771:     // Visual feedback: you could add a highlight to the container
 2772:     const container = event.currentTarget;
 2773:     container.classList.add('drag-over');
 2774: }
 2775: 
 2776: function handleProgramRoutineDragLeave(event) {
 2777:     const container = event.currentTarget;
 2778:     container.classList.remove('drag-over');
 2779: }
 2780: 
 2781: function handleProgramRoutineDrop(event) {
 2782:     event.preventDefault();
 2783:     const container = event.currentTarget;
 2784:     container.classList.remove('drag-over');
 2785: 
 2786:     if (programDraggedChip) {
 2787:         const newDayValue = container.closest('.day-column').dataset.dayValue;
 2788: 
 2789:         // Update the hidden input's name to reflect the new day
 2790:         const hiddenInput = programDraggedChip.querySelector('input[type="hidden"]');
 2791:         if (hiddenInput) {
 2792:             hiddenInput.name = `weekly_day_${newDayValue}_routines`;
 2793:         }
 2794: 
 2795:         // Move the chip to the new container
 2796:         container.appendChild(programDraggedChip);
 2797:         programDraggedChip.classList.remove('drag-source-hidden');
 2798:     }
 2799: }
 2800: 
 2801: function setupProgramRoutineDragListeners(chip) {
 2802:     if (!chip) {
 2803:         return;
 2804:     }
 2805: 
 2806:     if (chip.dataset.programRoutineListenersBound === 'true') {
 2807:         return;
 2808:     }
 2809: 
 2810:     chip.dataset.programRoutineListenersBound = 'true';
 2811: 
 2812:     chip.addEventListener('dragstart', (event) => {
 2813:         resetDoubleActivateState();
 2814:         handleProgramRoutineDragStart(event);
 2815:     });
 2816: 
 2817:     chip.addEventListener('dragend', (event) => {
 2818:         handleProgramRoutineDragEnd(event);
 2819:         resetDoubleActivateState();
 2820:     });
 2821: 
 2822:     addTouchDragSupport(chip, 'program-routines');
 2823: 
 2824:     if (!chip.hasAttribute('tabindex')) {
 2825:         chip.tabIndex = 0;
 2826:     }
 2827: 
 2828:     const routineName = chip.dataset.routineName || chip.querySelector('.routine-chip-label')?.textContent?.trim() || chip.textContent.trim();
 2829:     const labelText = routineName ? `${routineName}. ${ROUTINE_ACTIVATION_HINT}` : ROUTINE_ACTIVATION_HINT;
 2830:     chip.setAttribute('aria-label', labelText);
 2831:     chip.setAttribute('title', ROUTINE_ACTIVATION_HINT);
 2832: 
 2833:     attachDoubleActivate(chip, () => {
 2834:         const routineId = chip.dataset.routineId;
 2835:         if (routineId) {
 2836:             openRoutineDetail(routineId);
 2837:         }
 2838:     }, {
 2839:         isDragging: () => Boolean(programDraggedChip) || touchDragData.isDragging,
 2840:         shouldIgnore: (event) => Boolean(event.target.closest('[data-ignore-double-activate="true"]'))
 2841:     });
 2842: }
 2843: 
 2844: function setupSequentialRoutineActivation(row) {
 2845:     if (!row) {
 2846:         return;
 2847:     }
 2848: 
 2849:     const routineIdInput = row.querySelector('input[name*="_routine_id"]');
 2850:     const routineNameField = row.querySelector('input[type="text"][readonly]');
 2851: 
 2852:     if (!routineIdInput || !routineNameField) {
 2853:         return;
 2854:     }
 2855: 
 2856:     routineNameField.dataset.routineId = routineIdInput.value;
 2857:     routineNameField.dataset.routineName = routineNameField.value;
 2858:     routineNameField.setAttribute('title', ROUTINE_ACTIVATION_HINT);
 2859:     const routineLabel = routineNameField.value ? `${routineNameField.value}. ${ROUTINE_ACTIVATION_HINT}` : ROUTINE_ACTIVATION_HINT;
 2860:     routineNameField.setAttribute('aria-label', routineLabel);
 2861: 
 2862:     attachDoubleActivate(routineNameField, () => {
 2863:         const routineId = routineIdInput.value;
 2864:         if (routineId) {
 2865:             openRoutineDetail(routineId);
 2866:         }
 2867:     }, {
 2868:         forceTabIndex: false,
 2869:         isDragging: () => touchDragData.isDragging,
 2870:         shouldIgnore: (event) => Boolean(event.target.closest('.remove-pr-btn'))
 2871:     });
 2872: }
 2873: 
 2874: function initializeProgramRoutinesDragDrop() {
 2875:     const weeklyContainer = document.getElementById('weekly-schedule-container');
 2876:     if (!weeklyContainer) return;
 2877: 
 2878:     // Set up drag and drop for all existing routine chips
 2879:     weeklyContainer.querySelectorAll('.routine-chip').forEach(chip => {
 2880:         setupProgramRoutineDragListeners(chip);
 2881:     });
 2882: 
 2883:     // Set up drop zones for each day
 2884:     weeklyContainer.querySelectorAll('.routines-for-day-container').forEach(container => {
 2885:         container.addEventListener('dragover', handleProgramRoutineDragOver);
 2886:         container.addEventListener('dragleave', handleProgramRoutineDragLeave);
 2887:         container.addEventListener('drop', handleProgramRoutineDrop);
 2888:     });
 2889: }
 2890: 
 2891: // ======================================
 2892: //      PROGRAM FORM FUNCTIONS
 2893: // ======================================
 2894: 
 2895: window.handleAddRoutineToProgram = function() { // This function is now globally accessible
 2896:     const select = document.getElementById('add-routine-select');
 2897:     const selectedOption = select.options[select.selectedIndex];
 2898:     if (!selectedOption || !selectedOption.value) {
 2899:         send_toast('Please select a routine to add.', 'warning');
 2900:         return;
 2901:     }
 2902: 
 2903:     const routineId = selectedOption.value;
 2904:     const routineName = selectedOption.dataset.name;
 2905: 
 2906:     // Remove the option from the select to prevent adding it again
 2907:     selectedOption.remove();
 2908:     select.value = ''; // Reset select
 2909: 
 2910:     // Get the template
 2911:     const template = document.getElementById('program-routine-template');
 2912:     if (!template) {
 2913:         console.error('Program routine template not found!');
 2914:         return;
 2915:     }
 2916: 
 2917:     // Get the container and create a new row from the template
 2918:     const container = document.getElementById('program-routines-container');
 2919:     const newIndex = container.querySelectorAll('.program-routine-row').length;
 2920:     const newOrder = newIndex + 1; // Default order
 2921: 
 2922:     let newRowHTML = template.innerHTML;
 2923:     newRowHTML = newRowHTML.replace(/__INDEX__/g, newIndex)
 2924:                            .replace(/__ROUTINE_ID__/g, routineId)
 2925:                            .replace(/__ROUTINE_NAME__/g, routineName)
 2926:                            .replace(/__ORDER__/g, newOrder);
 2927: 
 2928:     const tempDiv = document.createElement('div');
 2929:     tempDiv.innerHTML = newRowHTML;
 2930:     const newRow = tempDiv.firstElementChild; // The new .program-routine-row div
 2931: 
 2932:     container.appendChild(newRow);
 2933:     setupSequentialRoutineActivation(newRow);
 2934: }
 2935: 
 2936: window.handleRemoveProgramRoutine = function(event) { // This function is now globally accessible
 2937:     const row = event.target.closest('.program-routine-row');
 2938:     if (!row) return;
 2939: 
 2940:     const routineId = row.querySelector('input[name*="_routine_id"]').value;
 2941:     const routineName = row.querySelector('input[readonly]').value;
 2942: 
 2943:     // Add the routine back to the select dropdown
 2944:     const select = document.getElementById('add-routine-select');
 2945:     if (select && routineId && routineName) {
 2946:         const option = document.createElement('option');
 2947:         option.value = routineId;
 2948:         option.textContent = routineName;
 2949:         option.dataset.name = routineName;
 2950:         select.appendChild(option);
 2951:     }
 2952: 
 2953:     row.remove();
 2954: 
 2955:     // After removing, we might want to re-index the remaining rows
 2956:     // to ensure form submission works correctly if the backend expects
 2957:     // a continuous sequence of indices.
 2958:     const container = document.getElementById('program-routines-container');
 2959:     const rows = container.querySelectorAll('.program-routine-row');
 2960:     rows.forEach((r, index) => {
 2961:         r.dataset.index = index;
 2962:         r.querySelectorAll('input, select').forEach(input => {
 2963:             if (input.name) {
 2964:                 input.name = input.name.replace(/program_routine_\d+/, `program_routine_${index}_`);
 2965:             }
 2966:             if (input.id) {
 2967:                 input.id = input.id.replace(/_\d+$/, `_${index}`);
 2968:             }
 2969:         });
 2970:     });
 2971: }
 2972: 
 2973: function handleAddRoutineToDay(event) {
 2974:     const select = event.target;
 2975:     const selectedOption = select.options[select.selectedIndex];
 2976:     if (!selectedOption || !selectedOption.value) return;
 2977: 
 2978:     const routineId = selectedOption.value;
 2979:     const routineName = selectedOption.textContent;
 2980:     const dayColumn = select.closest('.day-column');
 2981:     const dayValue = dayColumn.dataset.dayValue;
 2982:     const container = dayColumn.querySelector('.routines-for-day-container');
 2983: 
 2984:     // Create the chip
 2985:     const chip = document.createElement('div');
 2986:     chip.className = 'routine-chip';
 2987:     chip.draggable = true; // Make it draggable
 2988:     chip.dataset.routineId = routineId;
 2989:     chip.dataset.routineName = routineName; // Store name for drag and drop
 2990:     chip.innerHTML = `
 2991:         <span class="routine-chip-label">${routineName}</span>
 2992:         <div class="d-flex align-items-center">
 2993:             <button type="button" class="btn-close btn-close-white btn-sm" data-ignore-double-activate="true" aria-label="Remove"></button>
 2994:         </div>
 2995:         <input type="hidden" name="weekly_day_${dayValue}_routines" value="${routineId}">
 2996:     `;
 2997: 
 2998:     container.appendChild(chip);
 2999: 
 3000:     // Set up drag and drop listeners for the new chip
 3001:     setupProgramRoutineDragListeners(chip);
 3002: 
 3003:     // Reset the select
 3004:     select.value = '';
 3005: }
 3006: 
 3007: function handleRemoveRoutineFromDay(chipElement) {
 3008:     chipElement.remove();
 3009: }
 3010: 
 3011: 
 3012: // ======================================
 3013: //      MOBILE TOUCH DRAG & DROP SUPPORT
 3014: // ======================================
 3015: 
 3016: let touchDragData = {
 3017:     isDragging: false,
 3018:     draggedElement: null,
 3019:     startX: 0,
 3020:     startY: 0,
 3021:     offsetX: 0,
 3022:     offsetY: 0,
 3023:     clone: null,
 3024:     originalParent: null,
 3025:     dragType: null // 'routine-exercises', 'workout-exercises', 'program-routines'
 3026: };
 3027: 
 3028: function addTouchDragSupport(element, dragType) {
 3029:     if (!element || element.dataset.touchDragBound === 'true') {
 3030:         return;
 3031:     }
 3032: 
 3033:     element.dataset.touchDragBound = 'true';
 3034:     element.addEventListener('touchstart', (e) => handleTouchStart(e, dragType), { passive: false });
 3035:     element.addEventListener('touchmove', handleTouchMove, { passive: false });
 3036:     element.addEventListener('touchend', handleTouchEnd, { passive: false });
 3037: }
 3038: function handleTouchStart(event, dragType) {
 3039:     if (event.touches.length !== 1) return;
 3040: 
 3041:     const touch = event.touches[0];
 3042:     const element = event.currentTarget;
 3043: 
 3044:     // Only start drag for draggable elements
 3045:     if (!element.draggable) return;
 3046: 
 3047:     touchDragData.isDragging = false; // Will be set to true in touchmove if threshold exceeded
 3048:     touchDragData.draggedElement = element;
 3049:     touchDragData.startX = touch.clientX;
 3050:     touchDragData.startY = touch.clientY;
 3051:     touchDragData.dragType = dragType;
 3052:     touchDragData.originalParent = element.parentNode;
 3053: 
 3054:     const rect = element.getBoundingClientRect();
 3055:     touchDragData.offsetX = touch.clientX - rect.left;
 3056:     touchDragData.offsetY = touch.clientY - rect.top;
 3057: 
 3058:     // Prevent default to avoid scrolling while potentially dragging
 3059:     event.preventDefault();
 3060: }
 3061: 
 3062: function handleTouchMove(event) {
 3063:     if (!touchDragData.draggedElement || event.touches.length !== 1) return;
 3064: 
 3065:     const touch = event.touches[0];
 3066:     const deltaX = Math.abs(touch.clientX - touchDragData.startX);
 3067:     const deltaY = Math.abs(touch.clientY - touchDragData.startY);
 3068: 
 3069:     // Threshold to start dragging (prevents accidental drags)
 3070:     if (!touchDragData.isDragging && (deltaX > 10 || deltaY > 10)) {
 3071:         touchDragData.isDragging = true;
 3072:         startTouchDrag(event);
 3073:     }
 3074: 
 3075:     if (touchDragData.isDragging) {
 3076:         updateTouchDrag(event);
 3077:     }
 3078: 
 3079:     event.preventDefault();
 3080: }
 3081: 
 3082: function startTouchDrag(event) {
 3083:     const element = touchDragData.draggedElement;
 3084: 
 3085:     // Create visual clone
 3086:     touchDragData.clone = element.cloneNode(true);
 3087:     touchDragData.clone.classList.add('dragging-clone');
 3088:     touchDragData.clone.style.pointerEvents = 'none';
 3089:     touchDragData.clone.style.transform = 'rotate(5deg)';
 3090:     touchDragData.clone.style.opacity = '0.8';
 3091: 
 3092:     const rect = element.getBoundingClientRect();
 3093:     touchDragData.clone.style.width = `${rect.width}px`;
 3094:     touchDragData.clone.style.height = `${rect.height}px`;
 3095: 
 3096:     document.body.appendChild(touchDragData.clone);
 3097: 
 3098:     // Hide original element
 3099:     element.classList.add('drag-source-hidden');
 3100: 
 3101:     // Call appropriate drag start handler
 3102:     simulateDragStart(element);
 3103: }
 3104: 
 3105: function updateTouchDrag(event) {
 3106:     if (!touchDragData.clone) return;
 3107: 
 3108:     const touch = event.touches[0];
 3109:     touchDragData.clone.style.left = `${touch.clientX - touchDragData.offsetX}px`;
 3110:     touchDragData.clone.style.top = `${touch.clientY - touchDragData.offsetY}px`;
 3111: 
 3112:     // Find element under touch (excluding the clone)
 3113:     touchDragData.clone.style.display = 'none';
 3114:     const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
 3115:     touchDragData.clone.style.display = 'block';
 3116: 
 3117:     if (elementBelow) {
 3118:         handleTouchDragOver(elementBelow, touch);
 3119:     }
 3120: }
 3121: 
 3122: function handleTouchDragOver(elementBelow, touch) {
 3123:     const draggedElement = touchDragData.draggedElement;
 3124: 
 3125:     switch (touchDragData.dragType) {
 3126:         case 'routine-exercises':
 3127:             const routineContainer = document.getElementById('routine-exercises-container');
 3128:             if (routineContainer && routineContainer.contains(elementBelow)) {
 3129:                 // Simulate routine exercise reordering
 3130:                 const afterElement = getDragAfterElement(routineContainer, touch.clientY, draggedElement);
 3131:                 if (afterElement && afterElement !== draggedElement) {
 3132:                     routineContainer.insertBefore(draggedElement, afterElement);
 3133:                 } else if (!afterElement) {
 3134:                     routineContainer.appendChild(draggedElement);
 3135:                 }
 3136:             }
 3137:             break;
 3138: 
 3139:         case 'workout-exercises':
 3140:             const categoryContainer = elementBelow.closest('.exercise-category-container');
 3141:             if (categoryContainer) {
 3142:                 const afterElement = getWorkoutDragAfterElement(categoryContainer, touch.clientY, draggedElement);
 3143:                 if (afterElement && afterElement !== draggedElement) {
 3144:                     categoryContainer.insertBefore(draggedElement, afterElement);
 3145:                 } else if (!afterElement) {
 3146:                     categoryContainer.appendChild(draggedElement);
 3147:                 }
 3148:             }
 3149:             break;
 3150: 
 3151:         case 'program-routines':
 3152:             const dayContainer = elementBelow.closest('.routines-for-day-container');
 3153:             if (dayContainer && dayContainer !== touchDragData.originalParent) {
 3154:                 // Update hidden input for new day
 3155:                 const newDayValue = dayContainer.closest('.day-column').dataset.dayValue;
 3156:                 const hiddenInput = draggedElement.querySelector('input[type="hidden"]');
 3157:                 if (hiddenInput) {
 3158:                     hiddenInput.name = `weekly_day_${newDayValue}_routines`;
 3159:                 }
 3160:                 dayContainer.appendChild(draggedElement);
 3161:             }
 3162:             break;
 3163:     }
 3164: }
 3165: 
 3166: function handleTouchEnd(event) {
 3167:     if (!touchDragData.isDragging) {
 3168:         // Not a drag, might be a tap - reset and allow normal behavior
 3169:         resetTouchDrag();
 3170:         return;
 3171:     }
 3172: 
 3173:     event.preventDefault();
 3174: 
 3175:     if (touchDragData.draggedElement) {
 3176:         // Restore visibility
 3177:         touchDragData.draggedElement.classList.remove('drag-source-hidden');
 3178: 
 3179:         // Call appropriate update functions
 3180:         switch (touchDragData.dragType) {
 3181:             case 'routine-exercises':
 3182:                 updateRoutineExerciseOrderNumbers();
 3183:     bindRoutineSetSyncHandlers(newCard);
 3184:                 break;
 3185:             case 'workout-exercises':
 3186:                 const container = touchDragData.draggedElement.closest('.exercise-category-container');
 3187:                 if (container) {
 3188:                     updateWorkoutExerciseOrder(container);
 3189:                 }
 3190:                 break;
 3191:             case 'program-routines':
 3192:                 // Program routine updates are handled in handleTouchDragOver
 3193:                 break;
 3194:         }
 3195:     }
 3196: 
 3197:     resetTouchDrag();
 3198: }
 3199: 
 3200: function simulateDragStart(element) {
 3201:     // Set the appropriate global drag variables based on drag type
 3202:     switch (touchDragData.dragType) {
 3203:         case 'routine-exercises':
 3204:             draggedItem = element;
 3205:             break;
 3206:         case 'workout-exercises':
 3207:             workoutDraggedItem = element;
 3208:             break;
 3209:         case 'program-routines':
 3210:             programDraggedChip = element;
 3211:             break;
 3212:     }
 3213: }
 3214: 
 3215: function resetTouchDrag() {
 3216:     if (touchDragData.clone) {
 3217:         document.body.removeChild(touchDragData.clone);
 3218:     }
 3219: 
 3220:     if (touchDragData.draggedElement) {
 3221:         touchDragData.draggedElement.classList.remove('drag-source-hidden');
 3222:     }
 3223: 
 3224:     // Reset global drag variables
 3225:     draggedItem = null;
 3226:     workoutDraggedItem = null;
 3227:     programDraggedChip = null;
 3228: 
 3229:     touchDragData = {
 3230:         isDragging: false,
 3231:         draggedElement: null,
 3232:         startX: 0,
 3233:         startY: 0,
 3234:         offsetX: 0,
 3235:         offsetY: 0,
 3236:         clone: null,
 3237:         originalParent: null,
 3238:         dragType: null
 3239:     };
 3240:     resetDoubleActivateState();
 3241: }
 3242: 
 3243: // ======================================
 3244: //      INITIALIZE TOUCH SUPPORT
 3245: // ======================================
 3246: 
 3247: function initializeTouchDragSupport() {
 3248:     // Routine exercises
 3249:     const routineContainer = document.getElementById('routine-exercises-container');
 3250:     if (routineContainer) {
 3251:         routineContainer.querySelectorAll('.exercise-routine-card[draggable="true"]').forEach(card => {
 3252:             addTouchDragSupport(card, 'routine-exercises');
 3253:         });
 3254:     }
 3255: 
 3256:     // Workout exercises
 3257:     const workoutContainer = document.getElementById('workout-exercises-container');
 3258:     if (workoutContainer) {
 3259:         workoutContainer.querySelectorAll('.workout-exercise-card[draggable="true"]').forEach(card => {
 3260:             addTouchDragSupport(card, 'workout-exercises');
 3261:         });
 3262:     }
 3263: 
 3264:     // Program routine chips
 3265:     const weeklyContainer = document.getElementById('weekly-schedule-container');
 3266:     if (weeklyContainer) {
 3267:         weeklyContainer.querySelectorAll('.routine-chip[draggable="true"]').forEach(chip => {
 3268:             addTouchDragSupport(chip, 'program-routines');
 3269:         });
 3270:     }
 3271: }
 3272: let gainzAppInitialized = false;
 3273: 
 3274: function bootstrapGainzApp() {
 3275:     if (gainzAppInitialized) {
 3276:         return;
 3277:     }
 3278:     gainzAppInitialized = true;
 3279: 
 3280:     if (!mutationObserverStarted && document.body) {
 3281:         observer.observe(document.body, {
 3282:             childList: true,
 3283:             subtree: true,
 3284:             attributes: true,
 3285:             attributeFilter: ['data-function']
 3286:         });
 3287:         mutationObserverStarted = true;
 3288: 
 3289:         document.querySelectorAll('[data-function]').forEach(element => {
 3290:             const attr = element.getAttributeNode('data-function');
 3291:             if (attr) {
 3292:                 handle_attribute(element, attr);
 3293:             }
 3294:         });
 3295:     }
 3296: 
 3297:     initializeRoutineForm();
 3298:     initializeWorkoutExercisesDragDrop();
 3299:     initializeProgramRoutinesDragDrop();
 3300:     initializeTouchDragSupport();
 3301:     window.addEventListener('resize', initializeRoutineMobileView);
 3302: }
 3303: 
 3304: if (document.readyState === 'loading') {
 3305:     document.addEventListener('DOMContentLoaded', bootstrapGainzApp);
 3306: } else {
 3307:     bootstrapGainzApp();
 3308: }
 3309: function bindRoutineSetSyncHandlers(root) {
 3310:     const scope = root || document;
 3311:     const inputs = scope.querySelectorAll('#routine-exercises-container input[name*="_target_reps"], #routine-exercises-container input[name*="_target_weight"]');
 3312:     inputs.forEach(input => {
 3313:         if (input.dataset.routineSyncBound === 'true') {
 3314:             return;
 3315:         }
 3316:         input.addEventListener('focus', captureRoutineSetFieldOriginalValue);
 3317:         input.addEventListener('change', handleRoutineSetFieldChange);
 3318:         input.dataset.routineSyncBound = 'true';
 3319:     });
 3320: }
 3321: 
 3322: function bindWorkoutSetSyncHandlers(root) {
 3323:     const scope = root || document;
 3324:     const inputs = scope.querySelectorAll('.sets-container [data-field="reps"], .sets-container [data-field="weight"]');
 3325:     inputs.forEach(input => {
 3326:         if (input.dataset.workoutSyncBound === 'true') {
 3327:             return;
 3328:         }
 3329:         input.addEventListener('focus', captureWorkoutSetOriginalValue);
 3330:         input.addEventListener('blur', handleWorkoutSetChange);
 3331:         input.dataset.workoutSyncBound = 'true';
 3332:     });
 3333: }
 3334: function initializeRoutineMobileView() {
 3335:     const container = document.getElementById('routine-exercises-container');
 3336:     if (!container) return;
 3337:     if (!window.matchMedia('(max-width: 767px)').matches) {
 3338:         // Clear mobile wrappers if any
 3339:         if (container.dataset.routineMobileInit === 'true') {
 3340:             container.querySelectorAll('.routine-mobile-card').forEach(wrapper => {
 3341:                 const inner = wrapper.querySelector('.exercise-routine-card');
 3342:                 if (inner) container.insertBefore(inner, wrapper);
 3343:                 wrapper.remove();
 3344:             });
 3345:             const nav = document.getElementById('routine-exercise-mobile-nav');
 3346:             if (nav) nav.remove();
 3347:             delete container.dataset.routineMobileInit;
 3348:         }
 3349:         return;
 3350:     }
 3351:     refreshMobileRoutineUI();
 3352: }
 3353: 
 3354: function refreshMobileRoutineUI(preferredIndex = null) {
 3355:     const container = document.getElementById('routine-exercises-container');
 3356:     if (!container) return;
 3357: 
 3358:     // Wrap cards if not already
 3359:     const cards = Array.from(container.querySelectorAll(':scope > .exercise-routine-card'));
 3360:     cards.forEach((card, idx) => {
 3361:         if (!card.parentElement.classList.contains('routine-mobile-card')) {
 3362:             const wrapper = document.createElement('div');
 3363:             wrapper.className = 'exercise-card routine-mobile-card d-none';
 3364:             wrapper.dataset.exerciseIndex = String(idx);
 3365:             container.insertBefore(wrapper, card);
 3366:             wrapper.appendChild(card);
 3367:         }
 3368:     });
 3369: 
 3370:     const wrappers = Array.from(container.querySelectorAll(':scope > .routine-mobile-card'));
 3371:     wrappers.forEach((w, i) => w.dataset.exerciseIndex = String(i));
 3372: 
 3373:     // Build nav if missing
 3374:     if (!document.getElementById('routine-exercise-mobile-nav')) {
 3375:         const nav = document.createElement('div');
 3376:         nav.id = 'routine-exercise-mobile-nav';
 3377:         nav.className = 'exercise-navigation-bottom d-flex justify-content-between align-items-center mt-3';
 3378:         nav.innerHTML = `
 3379:             <button class="btn btn-outline-secondary" id="routine-prev-exercise"><i class="fas fa-chevron-left"></i></button>
 3380:             <div class="d-flex align-items-center gap-3">
 3381:                 <div class="exercise-indicators" id="routine-exercise-indicators"></div>
 3382:                 <div class="exercise-counter"><span id="routine-current-exercise-num">1</span>/<span id="routine-total-exercises-num">${wrappers.length}</span></div>
 3383:             </div>
 3384:             <button class="btn btn-outline-secondary" id="routine-next-exercise"><i class="fas fa-chevron-right"></i></button>
 3385:         `;
 3386:         container.parentElement.appendChild(nav);
 3387: 
 3388:         nav.querySelector('#routine-prev-exercise').addEventListener('click', () => stepRoutineMobile(-1));
 3389:         nav.querySelector('#routine-next-exercise').addEventListener('click', () => stepRoutineMobile(1));
 3390:     }
 3391: 
 3392:     // Rebuild indicators
 3393:     const indicators = document.getElementById('routine-exercise-indicators');
 3394:     if (indicators) {
 3395:         indicators.innerHTML = '';
 3396:         wrappers.forEach((_, i) => {
 3397:             const dot = document.createElement('div');
 3398:             dot.className = 'indicator';
 3399:             dot.dataset.index = String(i);
 3400:             dot.addEventListener('click', () => showRoutineMobileIndex(i));
 3401:             indicators.appendChild(dot);
 3402:         });
 3403:     }
 3404: 
 3405:     const totalSpan = document.getElementById('routine-total-exercises-num');
 3406:     if (totalSpan) totalSpan.textContent = String(wrappers.length);
 3407: 
 3408:     let target = 0;
 3409:     const current = Number(container.dataset.routineCurrentIndex || '0');
 3410:     if (preferredIndex !== null && Number.isFinite(preferredIndex)) {
 3411:         target = Math.max(0, Math.min(preferredIndex, wrappers.length - 1));
 3412:     } else if (current >= 0 && current < wrappers.length) {
 3413:         target = current;
 3414:     }
 3415:     showRoutineMobileIndex(target);
 3416:     container.dataset.routineMobileInit = 'true';
 3417: }
 3418: 
 3419: function showRoutineMobileIndex(idx) {
 3420:     const container = document.getElementById('routine-exercises-container');
 3421:     if (!container) return;
 3422:     const wrappers = Array.from(container.querySelectorAll(':scope > .routine-mobile-card'));
 3423:     if (!wrappers.length) return;
 3424:     const clamped = Math.max(0, Math.min(idx, wrappers.length - 1));
 3425:     wrappers.forEach(w => w.classList.add('d-none'));
 3426:     wrappers[clamped].classList.remove('d-none');
 3427:     container.dataset.routineCurrentIndex = String(clamped);
 3428: 
 3429:     const prev = document.getElementById('routine-prev-exercise');
 3430:     const next = document.getElementById('routine-next-exercise');
 3431:     const curSpan = document.getElementById('routine-current-exercise-num');
 3432:     document.querySelectorAll('#routine-exercise-indicators .indicator').forEach((dot, i) => dot.classList.toggle('active', i === clamped));
 3433:     if (prev) prev.disabled = clamped === 0;
 3434:     if (next) next.disabled = clamped === wrappers.length - 1;
 3435:     if (curSpan) curSpan.textContent = String(clamped + 1);
 3436: }
 3437: 
 3438: function stepRoutineMobile(delta) {
 3439:     const container = document.getElementById('routine-exercises-container');
 3440:     if (!container) return;
 3441:     const current = Number(container.dataset.routineCurrentIndex || '0');
 3442:     showRoutineMobileIndex(current + delta);
 3443: }
 3444: 
 3445: 
 3446: 
 3447: 
